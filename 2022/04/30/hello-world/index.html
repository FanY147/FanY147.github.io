<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>JVM深入理解JAVA虚拟机 | MyBlog</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="MyBlog" type="application/atom+xml">
    
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">MyBlog</a></h1>
		<h2 class="header__subtitle">READ&LEARNING&LIFE&PHOTOGRAPHY</h2>
	</header>

	<main>
		<article>
	
		<h1>JVM深入理解JAVA虚拟机</h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-30</span><br />
		
		
	</div>

	

	
		<h1 id="一、JAVA内存区域与内存溢出异常"><a href="#一、JAVA内存区域与内存溢出异常" class="headerlink" title="一、JAVA内存区域与内存溢出异常"></a>一、JAVA内存区域与内存溢出异常</h1><h2 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h2><p>​		对于JAVA程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete&#x2F;free代码，不容易出现内存泄露和内存溢出问题，由虚拟机管理内存让一切都看起来很美好。不过，也正是因为JAVA程序员把内存控制的权利交给了JAVA虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将成为一项异常艰难的工作。</p>
<h2 id="1-2运行时数据区域"><a href="#1-2运行时数据区域" class="headerlink" title="1.2运行时数据区域"></a>1.2运行时数据区域</h2><p>​		JAVA虚拟机在执行JAVA程序的过程中会把它所管理的内存化为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁，根据最新的JAVA虚拟机规范的规定，JAVA虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示1-1所示。<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202204301922679.png"></figure></p>
<h3 id="1-2-1程序计数器"><a href="#1-2-1程序计数器" class="headerlink" title="1.2.1程序计数器"></a>1.2.1程序计数器</h3><p>​		程序计数器是一块较小的内存空间，它可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要以来这个计数器来完成。</p>
<p>​		由于JAVA虚拟机的多线程是通过线程轮流切换并分配执行器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每个线程都需要有一个独立的程序计数器</strong>。各条线程之间计数器<strong>互不影响，独立存储</strong>，我们称这类内存区域为“线程私有”的内存。</p>
<p>​		如果线程正在实行的是一个JAVA方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在JAVA虚拟机规范中没有任何规定OOM情况的区域。</p>
<ul>
<li>作用<ul>
<li>为当前线程标识所要执行的字节码行号。</li>
<li>实现执行过程中分支、循环、跳转、异常处理、线程回复等基础功能。</li>
</ul>
</li>
<li>特点<ul>
<li>每个线程私有.</li>
<li>不存在OOM情况。</li>
</ul>
</li>
</ul>
<h3 id="1-2-2JAVA虚拟机栈"><a href="#1-2-2JAVA虚拟机栈" class="headerlink" title="1.2.2JAVA虚拟机栈"></a>1.2.2JAVA虚拟机栈</h3><p>​		虚拟机栈与程序计数器一样，也是线程私有的，其生命周期和线程相同，虚拟机栈描述的是JAVA方法执行的内存模型，<strong>每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接和方法出口等信息</strong>，每个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中从入栈到出栈的过程。</p>
<p>​		所谓的栈即当前讲的虚拟机栈，具体指的就是虚拟机栈中的局部变量表部分。局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、flout、long、double）、对象引用（不等同于对象本身，可能是一个指向对象起始位置的指针，也可能是指向一个代表对象的句柄等等）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间，其余数据类型会占一个。局部变量表的大小在编译期间完成分配，当进入一个方法是，这个方法需要在帧中分配多大的局部变量空间完全确定，在方法运行期间不会改变局部变量表的大小。</p>
<p>​		在JAVA虚拟机规范中，对这个去规定了两种异常情况，如果线程请求的栈深度大雨虚拟机所允许的最大深度，将抛出StackOverflowErrory异常；如果虚拟机可以动态扩展，但扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<ul>
<li>作用<ul>
<li>为当前方法提供内存空间，存储局部变量表、操作数栈、动态链接和方法出口等信息。包含的数据类型有基础数据类型、所引用对象的引用指针。</li>
</ul>
</li>
<li>特点<ul>
<li>局部变量表大小在编译期间确定，方法运行时不会改变。</li>
<li>会出现溢出情况。虚拟机栈中，<strong>栈帧过多</strong>（无限递归）、每个栈帧所占用过大会导致这种情况。<ul>
<li>StackOverflowErrory：栈深度大于当前虚拟机所允许的最大深度时抛出。</li>
<li>OutOfMemoryError：当虚拟机可以动态扩展但无法申请到足够的内存时抛出。</li>
</ul>
</li>
</ul>
</li>
<li>问题辨析<ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的。</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题。</li>
</ul>
</li>
</ul>
</li>
<li>CPU占用过高解决步骤（Linux）<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程。<ul>
<li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高。</li>
<li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高。</li>
<li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-3本地方法栈"><a href="#1-2-3本地方法栈" class="headerlink" title="1.2.3本地方法栈"></a>1.2.3本地方法栈</h3><p>​		本地方法栈与虚拟机栈所发挥的作用极其相似，它们之间的差别时虚拟机栈执行的是JAVA方法（也就是字节码）服务，而本地方法栈则为虚拟机执行的Native方法服务，本地方法栈中方法使用的语言、使用方式与数据结构没有强制规定。在有些虚拟机中，会把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowErrory和OutOfMemoryError异常。</p>
<h3 id="1-2-4JAVA堆"><a href="#1-2-4JAVA堆" class="headerlink" title="1.2.4JAVA堆"></a>1.2.4JAVA堆</h3><p>​		JAVA堆式JAVA虚拟机所管理的内存中最大的一块。JAVA堆式被所有线程共享的一块内存区域，在虚拟机启动时创建，其唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。在JAVA虚拟机规范中的描述：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换等优化技术会导致一些微妙的变化，所有的对象在堆上分配这件事不再那么绝对了。</p>
<p>​		JAVA堆式垃圾收集器管理的主要区域。从内存回收的角度看，由于现在收集器基本都是采用分代收集算法，所以JAVA堆中还可细分为：新生代和老年代；再细致一点还有线程共享的Eden区、From Survivor区、To Survivor区等。从内存分配的角度看，线程共享的JAVA堆中可能划分出多个线程私有的分配缓冲区（TLAB）。不过无论如何划分都和存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步的划分只是为了更好的回收内存，或者更快的分配内存。再物理空间上，JAVA堆可以是不连续的，只要逻辑上连续的即可。具体的是现实，既可是固定大小的，也可以是动态可扩展的，不过当前主流的虚拟机都是可扩展的，通过Xmx、Xms控制，如果在对中没有内存完成实力分配，且堆是无法扩展的，将会抛出OOM异常。</p>
<ul>
<li>作用<ul>
<li>存放对象实例</li>
</ul>
</li>
<li>特点<ul>
<li>当对象实例无法分配到内存中时，抛出OOM异常。</li>
</ul>
</li>
</ul>
<h3 id="1-2-5方法区"><a href="#1-2-5方法区" class="headerlink" title="1.2.5方法区"></a>1.2.5方法区</h3><p>​		方法区和JAVA堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然JAVA虚拟机规范把方法区描述为堆的一个逻辑部分，但他有一个别名叫做Non-Heap，与堆做区分。</p>
<p>​		JAVA虚拟机对于方法区的限制很少，除了和对一样可以使用不连续物理空间的内存意外，还可以选择不进行垃圾收集。相对而言，垃圾收集行为在方法区中很少出现，但也并非是数据进入了方法区后就如永久代的名字一样“永久”存在了。这个区域的垃圾回收主要是针对常量池的回收和类的卸载，一般来说，这个区域的回收效果微乎其微，尤其是类的卸载，相当苛刻，但是这部分的区域垃圾回收是必要的，当方法区无法满足内存分配需求是，将抛出OOM异常。</p>
<ul>
<li>作用<ul>
<li>存放类的加载信息：类信息、常量、静态变量等等。</li>
</ul>
</li>
<li>特点<ul>
<li>很少出现垃圾回收现象，但是不能缺少这一功能。</li>
<li>当方法去无法满足内存分配时，会出现OOm异常。</li>
</ul>
</li>
</ul>
<h3 id="1-2-6运行时常量池"><a href="#1-2-6运行时常量池" class="headerlink" title="1.2.6运行时常量池"></a>1.2.6运行时常量池</h3><p>​		运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类的加载后进入方法区的运行时常量池存放。一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>​		运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，JAVA语言并不要求常量只能在编译器才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被利用较多的便是String类的intern()方法，当常量池无法再申请到内存时会抛出OOM异常。</p>
<ul>
<li>作用<ul>
<li>存放编译器生成的字面量和符号引用，即常量。</li>
</ul>
</li>
<li>特点<ul>
<li>主要用于串池，可以再运行时放入新的常量。</li>
<li>当无法再申请到内存来存放常量时会抛出OOM异常</li>
</ul>
</li>
</ul>
<h3 id="1-2-7直接内存"><a href="#1-2-7直接内存" class="headerlink" title="1.2.7直接内存"></a>1.2.7直接内存</h3><p>​		直接内存的利用主要属于操作系统，常见于NIO操作时，用于数据缓冲区。在JDK14中，加入了NIO类，引入了一种基于通道与缓冲区的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在JAVA堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样可以在一些场景中提高性能，因为避免了在JAVA堆中和Native堆中来回复制数据。当内存分配不足时会发生OOM情况。</p>
<h2 id="1-3探秘对象"><a href="#1-3探秘对象" class="headerlink" title="1.3探秘对象"></a>1.3探秘对象</h2><h3 id="1-3-1对象的创建"><a href="#1-3-1对象的创建" class="headerlink" title="1.3.1对象的创建"></a>1.3.1对象的创建</h3><p>​		当虚拟机遇到一条new指令时，首先先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则必须先执行相应的类加载过程。</p>
<p>​		在类加载通过后，接下来虚拟机额将为新生对象分配内存，对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从堆中划分出来。假设JAVA堆中内存时完全规整的，所有用过的内存都放在一遍，空闲的内存放在另一边，中间放着一个指针作为分界点的治时期，那所分配内存仅仅是把那个指针向空闲内存那边挪动一段距离，距离大小等同于要分配的对象大小，这种分配方法称为“指针碰撞”。如果JAVA堆中的内存不是规整的，已使用的内存和空闲的内存交错分布，那么就要依靠虚拟机维护的一个列表，记录哪块内存块是可用的，在分配时从列表中找到一块足够大的内存划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。选择那种分配方式由堆决定，而堆是否规整又由所采用的垃圾收集器是否有压缩整理的功能决定，因此，在使用Serial、ParNew等带有压缩过程的收集器时，系统采用的是指针碰撞，而使用CMS这种已于标记清除的算法收集器时，采用空闲列表。</p>
<p>​		除了划分内存外，在对象创建时还要考虑多线程的影响，在并发情况下，如果出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来指针来分配内存的情况。有两种解决方案，一种是对分配内存空间的动作进行同步处理——利用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间上进行，即每个线程在JAVA堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。</p>
<p>​		内存分配完成之后虚拟机需要将分配的内存空间都初始化为0，这一操作保证了对象的实例字段在JAVA代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应了0值。接下来，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息放在对象的对象头之中，根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>​		虚拟机部分的操作基本完成后，从JAVA程序的角度看，对象创建还需&lt;“init”&gt;方法的执行，所有的字段赋值并初始化。流程如图1-2所示：<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202204301922772.png"></figure></p>
<h3 id="1-3-2对象的内存分布"><a href="#1-3-2对象的内存分布" class="headerlink" title="1.3.2对象的内存分布"></a>1.3.2对象的内存分布</h3><p>​		在HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对齐填充。</p>
<p>​		对象头包含两部分信息，一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分的长度在32位和64位虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态服用自己的存储空间。例如，在32位虚拟机中，如果对象处在未锁定状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码。4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0。对象的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。当对象是一个JAVA数组，那么对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通JAVA对象的元数据信息确定JAVA对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<p>​		接下来是实例数据部分，这部分是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p>
<p>​		第三部分对其填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用，由于虚拟的HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="1-3-3对象的访问定位"><a href="#1-3-3对象的访问定位" class="headerlink" title="1.3.3对象的访问定位"></a>1.3.3对象的访问定位</h3><p>​		对象的使用需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在JAVA虚拟机规范中只规定了一个指向对象的引用，并未规定定位、访问堆中对象的具体位置，主流的有使用句柄和直接指针两种方式。</p>
<ul>
<li>使用句柄：Java堆中将划分出一块内存来做句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据给的具体地址信息。</li>
<li>直接指针：reference中存储的直接是对象地址。</li>
</ul>
<h2 id="1-4实战：OutOfMemoryError异常"><a href="#1-4实战：OutOfMemoryError异常" class="headerlink" title="1.4实战：OutOfMemoryError异常"></a>1.4实战：OutOfMemoryError异常</h2><p>​		在虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有可能法伤OOM异常的可能。</p>
<h3 id="1-4-1JAVA堆溢出"><a href="#1-4-1JAVA堆溢出" class="headerlink" title="1.4.1JAVA堆溢出"></a>1.4.1JAVA堆溢出</h3><p>​		Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。</p>
<p>​		如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。 如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消 耗。</p>
<h3 id="1-4-2栈溢出"><a href="#1-4-2栈溢出" class="headerlink" title="1.4.2栈溢出"></a>1.4.2栈溢出</h3><p>​		由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。</p>
<p>​		关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
<ul>
<li><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
</li>
<li><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p>
</li>
</ul>
<p>​		这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。</p>
<p>​		在笔者的实验中，将实验范围限制于单线程中的操作，尝试了下面两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常，测试代码如代码清单如下所示。使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。</p>
<p>代码清单1-4 虚拟机栈和本地方法栈OOM测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*VM Args：-Xss128k</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackSOF</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> stackLength=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> stackLeak（）&#123;</span><br><span class="line">stackLength++；</span><br><span class="line">stackLeak（）；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）<span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">JavaVMStackSOF oom=<span class="keyword">new</span> <span class="title class_">JavaVMStackSOF</span>（）；</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">oom.stackLeak（）；</span><br><span class="line">&#125;<span class="keyword">catch</span>（Throwable e）&#123;</span><br><span class="line">System.out.println（<span class="string">&quot;stack length：&quot;</span>+oom.stackLength）；</span><br><span class="line"><span class="keyword">throw</span> e；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 </p>
<p>​		其实原因不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</p>
<p>​		这一点读者需要在开发多线程的应用时特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说在大多数情 况下）达到1000～2000完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。</p>
<p>​		代码清单1-5 创建线程导致内存溢出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*VM Args：-Xss2M（这时候不妨设置大些）</span><br><span class="line">*@author zzm</span><br><span class="line">*/</span><br><span class="line">public class JavaVMStackOOM&#123;</span><br><span class="line">private void dontStop（）&#123;</span><br><span class="line">while（true）&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void stackLeakByThread（）&#123;</span><br><span class="line">while（true）&#123;</span><br><span class="line">Thread thread=new Thread（new Runnable（）&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run（）&#123;</span><br><span class="line">dontStop（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;）；</span><br><span class="line">thread.start（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main（String[]args）throws Throwable&#123;</span><br><span class="line">JavaVMStackOOM oom=new JavaVMStackOOM（）；</span><br><span class="line">oom.stackLeakByThread（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3方法区和运行时常量池溢出"><a href="#1-4-3方法区和运行时常量池溢出" class="headerlink" title="1.4.3方法区和运行时常量池溢出"></a>1.4.3方法区和运行时常量池溢出</h3><p>​		由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。前面提到JDK1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。</p>
<p>​		String.intern（）是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX：PermSize和-XX：MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</p>
<p>代码清单1-6 运行时常量池导致的内存溢出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*VM Args：-XX：PermSize=10M-XX：MaxPermSize=10M</span><br><span class="line">*@author zzm</span><br><span class="line">*/</span><br><span class="line">public class RuntimeConstantPoolOOM&#123;</span><br><span class="line">public static void main（String[]args）&#123;</span><br><span class="line">//使用List保持着常量池引用，避免Full GC回收常量池行为</span><br><span class="line">List＜String＞list=new ArrayList＜String＞（）；</span><br><span class="line">//10MB的PermSize在integer范围内足够产生OOM了</span><br><span class="line">int i=0；</span><br><span class="line">while（true）&#123;</span><br><span class="line">list.add（String.valueOf（i++）.intern（））；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread<span class="string">&quot;main&quot;</span>java.lang.OutOfMemoryError：PermGen space</span><br><span class="line">at java.lang.String.intern（Native Method）</span><br><span class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main（RuntimeConstantPoolOOM.java：<span class="number">18</span>）</span><br></pre></td></tr></table></figure>

<p>​		从运行结果中可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。 而使用JDK1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响，如代码清单1-7所示。</p>
<p>代码清单1-7String.intern（）返回引用的测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeConstantPoolOOM</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line">String str1=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>（<span class="string">&quot;计算机&quot;</span>）.append（<span class="string">&quot;软件&quot;</span>）.toString（）；</span><br><span class="line">System.out.println（str1.intern（）==str1）；</span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>（<span class="string">&quot;ja&quot;</span>）.append（<span class="string">&quot;va&quot;</span>）.toString（）；</span><br><span class="line">System.out.println（str2.intern（）==str2）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这段代码在JDK1.6中运行，会得到两个false，而在JDK1.7中运行，会得到一个true和一个false。产生差异的原因是：</p>
<ul>
<li>在JDK1.6中，intern（）方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。</li>
<li>而JDK1.7（以及部分其他虚拟机，例如JRockit）的intern（）实现<strong>不会再复制实例，只是在常量池中记录首次出现的实例引用</strong>，因此intern（）返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString（）之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</li>
</ul>
<p>​		方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。在代码清单1-8中，借助C Glib直接操作字节码运行时生成了大量的动态类。 </p>
<p>​		值得特别注意的是，我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应用经常会出现在实际应用中：当前的很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到C Glib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的 Class可以加载入内存。另外，JVM上的动态语言（例如Groovy等）通常都会持续创建类来实现语言的动态性，随着这类语言的流行，也越来越容易遇到与代码清单1-8相似的溢出场景。</p>
<p>代码清单1-8 借助C Glib使方法区出现内存溢出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*VM Args：-XX：PermSize=10M-XX：MaxPermSize=10M</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMethodAreaOOM</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line"><span class="keyword">while</span>（<span class="literal">true</span>）&#123;</span><br><span class="line">Enhancer enhancer=<span class="keyword">new</span> <span class="title class_">Enhancer</span>（）；</span><br><span class="line">enhancer.setSuperclass（OOMObject.class）；</span><br><span class="line">enhancer.setUseCache（<span class="literal">false</span>）；</span><br><span class="line">enhancer.setCallback（<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>（）&#123;</span><br><span class="line"><span class="keyword">public</span> Object intercept（Object obj,Method method,Object[]args,MethodProxy proxy）<span class="keyword">throws</span> Throwable&#123;</span><br><span class="line"><span class="keyword">return</span> proxy.invokeSuper（obj,args）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;）；</span><br><span class="line">enhancer.create（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个 类文件，被不同的加载器加载也会视为不同的类）等。</p>
<h2 id="1-5-本章小结"><a href="#1-5-本章小结" class="headerlink" title="1.5 本章小结"></a>1.5 本章小结</h2><p>​		通过本章的学习，明白了虚拟机中的内存是如何划分的，哪部分区域、什么样的代码和操作可能导致内存溢出异常。虽然Java有垃圾收集机制，但内存溢出异常离我们仍然并不遥远，本章只是讲解了各个区域出现内存溢出异常的原因，下一章将详细讲解Java垃圾收集机制为了避免内存溢出异常的出现都做了哪些努力。</p>
<h1 id="二、垃圾收集器与内存分配策略"><a href="#二、垃圾收集器与内存分配策略" class="headerlink" title="二、垃圾收集器与内存分配策略"></a>二、垃圾收集器与内存分配策略</h1><h2 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h2><p>​		说起垃圾收集（Garbage Collection,GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分 配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：</p>
<ul>
<li>哪些内存需要回收？ </li>
<li>什么时候回收？ </li>
<li>如何回收？</li>
</ul>
<p>​		经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我 们就需要对这些“自动化”的技术实施必要的监控和调节。 </p>
<p>​		把时间从半个多世纪以前拨回到现在，回到我们熟悉的Java语言。第1章介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此 这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问 题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一 样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配 和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的“内存”分配与回 收也仅指这一部分内存。</p>
<h2 id="2-2对象已死吗"><a href="#2-2对象已死吗" class="headerlink" title="2.2对象已死吗"></a>2.2对象已死吗</h2><p>​		在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一 件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<h3 id="2-2-1引用计数算法"><a href="#2-2-1引用计数算法" class="headerlink" title="2.2.1引用计数算法"></a>2.2.1引用计数算法</h3><p>​		很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，<strong>每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1</strong>；<strong>任何时刻计数器为0的对象就是不可能再被使用的</strong>。作者面试过很多的应届生和一些有多年工作经验的开发人 员，他们对于这个问题给予的都是这个答案。</p>
<p>​		客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言和在游戏脚本领域被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但是，至少主流 的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它<strong>很难解决对象 之间相互循环引用的问题</strong>。 </p>
<p>​		举个简单的例子，请看代码清单2-1中的testGC（）方法：对象objA和objB都有字段 instance，赋值令objA.instance&#x3D;objB及objB.instance&#x3D;objA，除此之外，这两个对象再无任何引 用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的<strong>引用计数都不为0</strong>，于是引用计数算法无法通知GC收集器回收它们。</p>
<p>代码清单2-1 引用计数算法的缺陷</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*testGC（）方法执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span>&#123;</span><br><span class="line"><span class="keyword">public</span> Object instance=<span class="literal">null</span>；</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>；</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[]bigSize=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>*_1MB]；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testGC（）&#123;</span><br><span class="line">ReferenceCountingGC objA=<span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>（）；</span><br><span class="line">ReferenceCountingGC objB=<span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>（）；</span><br><span class="line">objA.instance=objB；</span><br><span class="line">objB.instance=objA；</span><br><span class="line">objA=<span class="literal">null</span>；</span><br><span class="line">objB=<span class="literal">null</span>；</span><br><span class="line"><span class="comment">//假设在这行发生GC,objA和objB是否能被回收？</span></span><br><span class="line">System.gc（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[F u l l G C（S y s t e m）[T e n u r e d：<span class="number">0</span> K-＞<span class="number">2</span> <span class="number">1</span> <span class="number">0</span> K（<span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> K），<span class="number">0.0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> s e c s]4603K-＞210K（19456K），[Perm：2999K-＞</span><br><span class="line">2999K（21248K）]，<span class="number">0.0150007</span> secs][Times：user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</span><br><span class="line">Heap</span><br><span class="line">def <span class="keyword">new</span> <span class="title class_">generation</span> total 9216K,used 82K[<span class="number">0x00000000055e0000</span>，<span class="number">0x0000000005fe0000</span>，<span class="number">0x0000000005fe0000</span>）</span><br><span class="line">Eden space 8192K，<span class="number">1</span>%used[<span class="number">0x00000000055e0000</span>，<span class="number">0x00000000055f4850</span>，<span class="number">0x0000000005de0000</span>）</span><br><span class="line">from space 1024K，<span class="number">0</span>%used[<span class="number">0x0000000005de0000</span>，<span class="number">0x0000000005de0000</span>，<span class="number">0x0000000005ee0000</span>）</span><br><span class="line">to space 1024K，<span class="number">0</span>%used[<span class="number">0x0000000005ee0000</span>，<span class="number">0x0000000005ee0000</span>，<span class="number">0x0000000005fe0000</span>）</span><br><span class="line">tenured generation total 10240K,used 210K[<span class="number">0x0000000005fe0000</span>，<span class="number">0x00000000069e0000</span>，<span class="number">0x00000000069e0000</span>）</span><br><span class="line">the space 10240K，<span class="number">2</span>%used[<span class="number">0x0000000005fe0000</span>，<span class="number">0x0000000006014a18</span>，<span class="number">0x0000000006014c00</span>，<span class="number">0x00000000069e0000</span>）</span><br><span class="line">compacting perm gen total 21248K,used 3016K[<span class="number">0x00000000069e0000</span>，<span class="number">0x0000000007ea0000</span>，<span class="number">0x000000000bde0000</span>）</span><br><span class="line">the space 21248K，<span class="number">14</span>%used[<span class="number">0x00000000069e0000</span>，<span class="number">0x0000000006cd2398</span>，<span class="number">0x0000000006cd2400</span>，<span class="number">0x0000000007ea0000</span>）</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure>

<p>从运行结果中可以清楚看到，GC日志中包含“4603K-＞210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机<strong>并不是通过引用计数算法来判断对象是否存活的</strong>。</p>
<h3 id="2-2-2-可达性分析算法"><a href="#2-2-2-可达性分析算法" class="headerlink" title="2.2.2 可达性分析算法"></a>2.2.2 可达性分析算法</h3><p>​		在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析（ReachabilityAnalysis）来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有<strong>任何引用链相连</strong>（用图论的话来说，就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。如图2-1所示，对象object5、object6、object7虽然互相有关联，但是它们到GCRoots是不可达的，所以它们将会被判定为是可回收的对象。</p>
<p><figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011130481.png"></figure></p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种： </p>
<ul>
<li><strong>虚拟机栈（栈帧中的本地变量表）中引用的对象。</strong> </li>
<li><strong>方法区中类静态属性引用的对象。</strong> </li>
<li><strong>方法区中常量引用的对象。</strong> </li>
<li><strong>本地方法栈中JNI（即一般说的Native方法）引用的对象。</strong></li>
</ul>

	

	
		<span class="different-posts"><a href="/2022/04/30/hello-world/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2022 Fresh Y | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
