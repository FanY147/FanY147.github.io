<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>JVM-自动内存管理机制 | MyBlog</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="MyBlog" type="application/atom+xml">
    
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

	<header class="header">
		<nav class="header__nav">
			
		</nav>
		<h1 class="header__title"><a href="/">MyBlog</a></h1>
		<h2 class="header__subtitle">READ&LEARNING&LIFE&PHOTOGRAPHY</h2>
	</header>

	<main>
		<article>
	
		<h1>JVM-自动内存管理机制</h1>
	
	<div class="article__infos">
		<span class="article__date">2022-05-03</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/Learning%EF%BC%88%E7%AC%AC%E4%B8%80%E5%B1%82%E7%BA%A7%EF%BC%89/">Learning（第一层级）</a> > <a class="article-category-link" href="/categories/Learning%EF%BC%88%E7%AC%AC%E4%B8%80%E5%B1%82%E7%BA%A7%EF%BC%89/JVM%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%B1%82%E7%BA%A7%EF%BC%89/">JVM（第二层级）</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/JAVA/" rel="tag">JAVA</a> <a class="article__tag-none-link" href="/tags/JVM/" rel="tag">JVM</a> <a class="article__tag-none-link" href="/tags/Learning/" rel="tag">Learning</a>
			</span>
		
	</div>

	

	
		<h1 id="一、JAVA内存区域与内存溢出异常"><a href="#一、JAVA内存区域与内存溢出异常" class="headerlink" title="一、JAVA内存区域与内存溢出异常"></a>一、JAVA内存区域与内存溢出异常</h1><h2 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h2><p>​		对于JAVA程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete&#x2F;free代码，不容易出现内存泄露和内存溢出问题，由虚拟机管理内存让一切都看起来很美好。不过，也正是因为JAVA程序员把内存控制的权利交给了JAVA虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将成为一项异常艰难的工作。</p>
<span id="more"></span>

<h2 id="1-2运行时数据区域"><a href="#1-2运行时数据区域" class="headerlink" title="1.2运行时数据区域"></a>1.2运行时数据区域</h2><p>​		JAVA虚拟机在执行JAVA程序的过程中会把它所管理的内存化为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁，根据最新的JAVA虚拟机规范的规定，JAVA虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示1-1所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202204301922679.png" style="zoom:67%;" /></figure>

<h3 id="1-2-1程序计数器"><a href="#1-2-1程序计数器" class="headerlink" title="1.2.1程序计数器"></a>1.2.1程序计数器</h3><p>​		程序计数器是一块较小的内存空间，它可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要以来这个计数器来完成。</p>
<p>​		由于JAVA虚拟机的多线程是通过线程轮流切换并分配执行器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每个线程都需要有一个独立的程序计数器</strong>。各条线程之间计数器<strong>互不影响，独立存储</strong>，我们称这类内存区域为“线程私有”的内存。</p>
<p>​		如果线程正在实行的是一个JAVA方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在JAVA虚拟机规范中没有任何规定OOM情况的区域。</p>
<ul>
<li>作用<ul>
<li>为当前线程标识所要执行的字节码行号。</li>
<li>实现执行过程中分支、循环、跳转、异常处理、线程回复等基础功能。</li>
</ul>
</li>
<li>特点<ul>
<li>每个线程私有.</li>
<li>不存在OOM情况。</li>
</ul>
</li>
</ul>
<h3 id="1-2-2JAVA虚拟机栈"><a href="#1-2-2JAVA虚拟机栈" class="headerlink" title="1.2.2JAVA虚拟机栈"></a>1.2.2JAVA虚拟机栈</h3><p>​		虚拟机栈与程序计数器一样，也是线程私有的，其生命周期和线程相同，虚拟机栈描述的是JAVA方法执行的内存模型，<strong>每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接和方法出口等信息</strong>，每个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中从入栈到出栈的过程。</p>
<p>​		所谓的栈即当前讲的虚拟机栈，具体指的就是虚拟机栈中的局部变量表部分。局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、flout、long、double）、对象引用（不等同于对象本身，可能是一个指向对象起始位置的指针，也可能是指向一个代表对象的句柄等等）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间，其余数据类型会占一个。局部变量表的大小在编译期间完成分配，当进入一个方法是，这个方法需要在帧中分配多大的局部变量空间完全确定，在方法运行期间不会改变局部变量表的大小。</p>
<p>​		在JAVA虚拟机规范中，对这个去规定了两种异常情况，如果线程请求的栈深度大雨虚拟机所允许的最大深度，将抛出StackOverflowErrory异常；如果虚拟机可以动态扩展，但扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<ul>
<li>作用<ul>
<li>为当前方法提供内存空间，存储局部变量表、操作数栈、动态链接和方法出口等信息。包含的数据类型有基础数据类型、所引用对象的引用指针。</li>
</ul>
</li>
<li>特点<ul>
<li>局部变量表大小在编译期间确定，方法运行时不会改变。</li>
<li>会出现溢出情况。虚拟机栈中，<strong>栈帧过多</strong>（无限递归）、每个栈帧所占用过大会导致这种情况。<ul>
<li>StackOverflowErrory：栈深度大于当前虚拟机所允许的最大深度时抛出。</li>
<li>OutOfMemoryError：当虚拟机可以动态扩展但无法申请到足够的内存时抛出。</li>
</ul>
</li>
</ul>
</li>
<li>问题辨析<ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的。</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题。</li>
</ul>
</li>
</ul>
</li>
<li>CPU占用过高解决步骤（Linux）<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程。<ul>
<li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高。</li>
<li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高。</li>
<li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-3本地方法栈"><a href="#1-2-3本地方法栈" class="headerlink" title="1.2.3本地方法栈"></a>1.2.3本地方法栈</h3><p>​		本地方法栈与虚拟机栈所发挥的作用极其相似，它们之间的差别时<strong>虚拟机栈执行的是JAVA方法（也就是字节码）服务</strong>，而<strong>本地方法栈则为虚拟机执行的Native方法服务</strong>，本地方法栈中方法使用的语言、使用方式与数据结构没有强制规定。在有些虚拟机中，会把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，<strong>本地方法栈区域也会抛出StackOverflowErrory和OutOfMemoryError异常</strong>。</p>
<h3 id="1-2-4JAVA堆"><a href="#1-2-4JAVA堆" class="headerlink" title="1.2.4JAVA堆"></a>1.2.4JAVA堆</h3><p>​		JAVA堆式JAVA虚拟机所管理的内存中最大的一块。<strong>JAVA堆式被所有线程共享</strong>的一块内存区域，在<strong>虚拟机启动时创建</strong>，其唯一的目的就是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。在JAVA虚拟机规范中的描述：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换等优化技术会导致一些微妙的变化，所有的对象在堆上分配这件事不再那么绝对了。</p>
<p>​		JAVA堆式垃圾收集器管理的主要区域。从内存回收的角度看，由于现在收集器基本都是采用<strong>分代收集算法</strong>，所以JAVA堆中还可细分为：<strong>新生代和老年代</strong>；再细致一点还有线程共享的<strong>Eden区、From Survivor区、To Survivor区</strong>等。从内存分配的角度看，线程共享的JAVA堆中可能<strong>划分出多个线程私有</strong>的<strong>分配缓冲区（TLAB）</strong>。不过无论如何划分都和存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步的划分只是为了更好的回收内存，或者更快的分配内存。再物理空间上，<strong>JAVA堆可以是不连续的，只要逻辑上连续的即可</strong>。具体的是现实，<strong>既可是固定大小的，也可以是动态可扩展的</strong>，不过当前主流的虚拟机都是可扩展的，通过Xmx、Xms控制，如果在对中没有内存完成实力分配，且堆是无法扩展的，将会抛出OOM异常。</p>
<ul>
<li>作用<ul>
<li><strong>存放对象实例</strong></li>
</ul>
</li>
<li>特点<ul>
<li><strong>当对象实例无法分配到内存中时，抛出OOM异常。</strong></li>
</ul>
</li>
</ul>
<h3 id="1-2-5方法区"><a href="#1-2-5方法区" class="headerlink" title="1.2.5方法区"></a>1.2.5方法区</h3><p>​		方法区和JAVA堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类信息、常量、静态变量</strong>、即时编译器编译后的代码等数据。虽然JAVA虚拟机规范把方法区描述为堆的一个逻辑部分，但他有一个别名叫做Non-Heap，与堆做区分。</p>
<p>​		JAVA虚拟机对于方法区的限制很少，除了和对一样可以使用不连续物理空间的内存意外，还可以选择不进行垃圾收集。相对而言，垃圾收集行为在方法区中很少出现，但也并非是数据进入了方法区后就如永久代的名字一样“永久”存在了。这个区域的垃圾回收主要是针对常量池的回收和类的卸载，一般来说，这个区域的回收效果微乎其微，尤其是类的卸载，相当苛刻，但是<strong>这部分的区域垃圾回收是必要的，当方法区无法满足内存分配需求是，将抛出OOM异常</strong>。</p>
<ul>
<li>作用<ul>
<li><strong>存放类的加载信息：类信息、常量、静态变量等等。</strong></li>
</ul>
</li>
<li>特点<ul>
<li><strong>很少出现垃圾回收现象，但是不能缺少这一功能。</strong></li>
<li><strong>当方法去无法满足内存分配时，会出现OOm异常。</strong></li>
</ul>
</li>
</ul>
<h3 id="1-2-6运行时常量池"><a href="#1-2-6运行时常量池" class="headerlink" title="1.2.6运行时常量池"></a>1.2.6运行时常量池</h3><p>​		运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池，用于<strong>存放编译器生成的各种字面量和符号引用</strong>，这部分内容将在类的加载后进入方法区的运行时常量池存放。一般来说，<strong>除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中</strong>。</p>
<p>​		运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，JAVA语言并不要求常量只能在编译器才能产生，<strong>也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被利用较多的便是String类的intern()方法，当常量池无法再申请到内存时会抛出OOM异常</strong>。</p>
<ul>
<li>作用<ul>
<li><strong>存放编译器生成的字面量和符号引用，即常量</strong>。</li>
</ul>
</li>
<li>特点<ul>
<li><strong>主要用于串池，可以再运行时放入新的常量。</strong></li>
<li><strong>当无法再申请到内存来存放常量时会抛出OOM异常</strong></li>
</ul>
</li>
</ul>
<h3 id="1-2-7直接内存"><a href="#1-2-7直接内存" class="headerlink" title="1.2.7直接内存"></a>1.2.7直接内存</h3><p>​		直接内存的利用主要属于操作系统，常见于NIO操作时，用于数据缓冲区。在JDK14中，加入了NIO类，引入了一种基于通道与缓冲区的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在JAVA堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样可以在一些场景中提高性能，因为避免了在JAVA堆中和Native堆中来回复制数据。<strong>当内存分配不足时会发生OOM情况。</strong></p>
<h2 id="1-3探秘对象"><a href="#1-3探秘对象" class="headerlink" title="1.3探秘对象"></a><strong>1.3探秘对象</strong></h2><h3 id="1-3-1对象的创建"><a href="#1-3-1对象的创建" class="headerlink" title="1.3.1对象的创建"></a>1.3.1对象的创建</h3><p>​		当虚拟机遇到一条new指令时，<strong>首先先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。</strong>如果没有，则必须先执行相应的<strong>类加载过程</strong>。</p>
<p>​		在类加载通过后，接下来虚拟机额将为新生对象<strong>分配内存</strong>，<strong>对象所需内存的大小在类加载完成后便可完全确定</strong>，为对象分配空间的任务等同于把一块确定大小的内存从堆中划分出来。<strong>假设JAVA堆中内存时完全规整的，所有用过的内存都放在一遍，空闲的内存放在另一边，中间放着一个指针作为分界点的治时期，那所分配内存仅仅是把那个指针向空闲内存那边挪动一段距离，距离大小等同于要分配的对象大小，这种分配方法称为“指针碰撞”</strong>。<strong>如果JAVA堆中的内存不是规整的，已使用的内存和空闲的内存交错分布，那么就要依靠虚拟机维护的一个列表，记录哪块内存块是可用的，在分配时从列表中找到一块足够大的内存划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</strong>选择那种分配方式由堆决定，而堆是否规整<strong>又由所采用的垃圾收集器是否有压缩整理的功能决定</strong>，因此，在使用Serial、ParNew等带有压缩过程的收集器时，系统采用的是指针碰撞，而使用<strong>CMS这种已于标记清除的算法收集器时，采用空闲列表</strong>。</p>
<p>​		除了划分内存外，在对象创建时还要考虑多线程的影响，在并发情况下，如果出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来指针来分配内存的情况。有两种解决方案，<strong>一种是对分配内存空间的动作进行同步处理——利用CAS配上失败重试的方式保证更新操作的原子性</strong>；<strong>另一种是把内存分配的动作按照线程划分在不同的空间上进行，即每个线程在JAVA堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。</strong></p>
<p>​		<strong>内存分配完成之后虚拟机需要将分配的内存空间都初始化为0，这一操作保证了对象的实例字段在JAVA代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应了0值。接下来，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</strong>这些信息放在对象的<strong>对象头</strong>之中，根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>​		虚拟机部分的操作基本完成后，从JAVA程序的角度看，<strong>对象创建还需&lt;“init”&gt;方法的执行，所有的字段赋值并初始化。</strong>流程如图所示：</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202204301922772.png" style="zoom:67%;" /></figure>

<h3 id="1-3-2对象的内存分布"><a href="#1-3-2对象的内存分布" class="headerlink" title="1.3.2对象的内存分布"></a>1.3.2对象的内存分布</h3><p>​		在HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头、实例数据和对齐填充</strong>。</p>
<p>​		对象头包含两部分信息，<strong>一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等</strong>，<strong>这部分的长度在32位和64位虚拟机中分别为32bit和64bit</strong>，官方称它为“<strong>Mark Word</strong>”。对象需要存储的运行时数据很多，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态服用自己的存储空间。例如，在32位虚拟机中，如果对象处在未锁定状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码。4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0。对象的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。当对象是一个JAVA数组，那么对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通JAVA对象的元数据信息确定JAVA对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<p>​		接下来是<strong>实例数据部分，这部分是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。</strong>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p>
<p>​		第三部分对其填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用，由于虚拟的HotSpot VM的自动内存管理系统要求<strong>对象起始地址必须是8字节的整数倍</strong>，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="1-3-3对象的访问定位"><a href="#1-3-3对象的访问定位" class="headerlink" title="1.3.3对象的访问定位"></a>1.3.3对象的访问定位</h3><p>​		对象的使用需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在JAVA虚拟机规范中只规定了一个指向对象的引用，并未规定定位、访问堆中对象的具体位置，主流的有使用句柄和直接指针两种方式。</p>
<ul>
<li><strong>使用句柄</strong>：Java堆中将划分出一块内存来做句柄池，reference中存储的就是对象的句柄地址，而<strong>句柄中包含了对象实例数据和类型数据给的具体地址信息</strong>。</li>
<li><strong>直接指针</strong>：reference中存储的直接是对象地址。</li>
</ul>
<h2 id="1-4实战：OutOfMemoryError异常"><a href="#1-4实战：OutOfMemoryError异常" class="headerlink" title="1.4实战：OutOfMemoryError异常"></a>1.4实战：OutOfMemoryError异常</h2><p>​		在虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有可能法伤OOM异常的可能。</p>
<h3 id="1-4-1JAVA堆溢出"><a href="#1-4-1JAVA堆溢出" class="headerlink" title="1.4.1JAVA堆溢出"></a>1.4.1JAVA堆溢出</h3><p>​		Java堆用于存储对象实例，只要<strong>不断地创建对象</strong>，<strong>并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制</strong>清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。</p>
<p>​		如果是<strong>内存泄露</strong>，可进一步通过工具<strong>查看泄露对象到GC Roots的引用链</strong>。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。 <strong>如果不存在泄露</strong>，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查<strong>虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大</strong>，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消 耗。</p>
<h3 id="1-4-2栈溢出"><a href="#1-4-2栈溢出" class="headerlink" title="1.4.2栈溢出"></a>1.4.2栈溢出</h3><p>​		由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。</p>
<p>​		关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
<ul>
<li><p>如果<strong>线程请求的栈深度大于虚拟机所允许的最大深度</strong>，将抛出StackOverflowError异常。</p>
</li>
<li><p>如果<strong>虚拟机在扩展栈时无法申请到足够的内存空间</strong>，则抛出OutOfMemoryError异常。</p>
</li>
</ul>
<p>​		这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。</p>
<p>​		在笔者的实验中，将实验范围限制于单线程中的操作，尝试了下面两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常，测试代码如代码清单如下所示。使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。</p>
<p>代码清单1-4 虚拟机栈和本地方法栈OOM测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*VM Args：-Xss128k</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackSOF</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> stackLength=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> stackLeak（）&#123;</span><br><span class="line">stackLength++；</span><br><span class="line">stackLeak（）；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）<span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">JavaVMStackSOF oom=<span class="keyword">new</span> <span class="title class_">JavaVMStackSOF</span>（）；</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">oom.stackLeak（）；</span><br><span class="line">&#125;<span class="keyword">catch</span>（Throwable e）&#123;</span><br><span class="line">System.out.println（<span class="string">&quot;stack length：&quot;</span>+oom.stackLength）；</span><br><span class="line"><span class="keyword">throw</span> e；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		<strong>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</strong>如果测试时不限于单线程，通过<strong>不断地建立线程的方式倒是可以产生内存溢出异常</strong>。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，<strong>为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</strong> </p>
<p>​		其实原因不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。<strong>每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</strong></p>
<p>​		这一点读者需要在开发多线程的应用时特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说在大多数情 况下）达到1000～2000完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。</p>
<p>​		代码清单1-5 创建线程导致内存溢出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*VM Args：-Xss2M（这时候不妨设置大些）</span><br><span class="line">*@author zzm</span><br><span class="line">*/</span><br><span class="line">public class JavaVMStackOOM&#123;</span><br><span class="line">private void dontStop（）&#123;</span><br><span class="line">while（true）&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void stackLeakByThread（）&#123;</span><br><span class="line">while（true）&#123;</span><br><span class="line">Thread thread=new Thread（new Runnable（）&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run（）&#123;</span><br><span class="line">dontStop（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;）；</span><br><span class="line">thread.start（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main（String[]args）throws Throwable&#123;</span><br><span class="line">JavaVMStackOOM oom=new JavaVMStackOOM（）；</span><br><span class="line">oom.stackLeakByThread（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3方法区和运行时常量池溢出"><a href="#1-4-3方法区和运行时常量池溢出" class="headerlink" title="1.4.3方法区和运行时常量池溢出"></a>1.4.3方法区和运行时常量池溢出</h3><p>​		由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。前面提到JDK1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。</p>
<p>​		String.intern（）是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX：PermSize和-XX：MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</p>
<p>代码清单1-6 运行时常量池导致的内存溢出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*VM Args：-XX：PermSize=10M-XX：MaxPermSize=10M</span><br><span class="line">*@author zzm</span><br><span class="line">*/</span><br><span class="line">public class RuntimeConstantPoolOOM&#123;</span><br><span class="line">public static void main（String[]args）&#123;</span><br><span class="line">//使用List保持着常量池引用，避免Full GC回收常量池行为</span><br><span class="line">List＜String＞list=new ArrayList＜String＞（）；</span><br><span class="line">//10MB的PermSize在integer范围内足够产生OOM了</span><br><span class="line">int i=0；</span><br><span class="line">while（true）&#123;</span><br><span class="line">list.add（String.valueOf（i++）.intern（））；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread<span class="string">&quot;main&quot;</span>java.lang.OutOfMemoryError：PermGen space</span><br><span class="line">at java.lang.String.intern（Native Method）</span><br><span class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main（RuntimeConstantPoolOOM.java：<span class="number">18</span>）</span><br></pre></td></tr></table></figure>

<p>​		从运行结果中可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。 而使用JDK1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响，如代码清单1-7所示。</p>
<p>代码清单1-7String.intern（）返回引用的测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeConstantPoolOOM</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line">String str1=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>（<span class="string">&quot;计算机&quot;</span>）.append（<span class="string">&quot;软件&quot;</span>）.toString（）；</span><br><span class="line">System.out.println（str1.intern（）==str1）；</span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>（<span class="string">&quot;ja&quot;</span>）.append（<span class="string">&quot;va&quot;</span>）.toString（）；</span><br><span class="line">System.out.println（str2.intern（）==str2）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这段代码在JDK1.6中运行，会得到两个false，而在JDK1.7中运行，会得到一个true和一个false。产生差异的原因是：</p>
<ul>
<li>在JDK1.6中，intern（）方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。</li>
<li>而JDK1.7（以及部分其他虚拟机，例如JRockit）的intern（）实现<strong>不会再复制实例，只是在常量池中记录首次出现的实例引用</strong>，因此intern（）返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString（）之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</li>
</ul>
<p>​		方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。在代码清单1-8中，借助C Glib直接操作字节码运行时生成了大量的动态类。 </p>
<p>​		值得特别注意的是，我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应用经常会出现在实际应用中：当前的很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到C Glib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的 Class可以加载入内存。另外，JVM上的动态语言（例如Groovy等）通常都会持续创建类来实现语言的动态性，随着这类语言的流行，也越来越容易遇到与代码清单1-8相似的溢出场景。</p>
<p>代码清单1-8 借助C Glib使方法区出现内存溢出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*VM Args：-XX：PermSize=10M-XX：MaxPermSize=10M</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMethodAreaOOM</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line"><span class="keyword">while</span>（<span class="literal">true</span>）&#123;</span><br><span class="line">Enhancer enhancer=<span class="keyword">new</span> <span class="title class_">Enhancer</span>（）；</span><br><span class="line">enhancer.setSuperclass（OOMObject.class）；</span><br><span class="line">enhancer.setUseCache（<span class="literal">false</span>）；</span><br><span class="line">enhancer.setCallback（<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>（）&#123;</span><br><span class="line"><span class="keyword">public</span> Object intercept（Object obj,Method method,Object[]args,MethodProxy proxy）<span class="keyword">throws</span> Throwable&#123;</span><br><span class="line"><span class="keyword">return</span> proxy.invokeSuper（obj,args）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;）；</span><br><span class="line">enhancer.create（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个 类文件，被不同的加载器加载也会视为不同的类）等。</p>
<h2 id="1-5-本章小结"><a href="#1-5-本章小结" class="headerlink" title="1.5 本章小结"></a>1.5 本章小结</h2><p>​		通过本章的学习，明白了虚拟机中的内存是如何划分的，哪部分区域、什么样的代码和操作可能导致内存溢出异常。虽然Java有垃圾收集机制，但内存溢出异常离我们仍然并不遥远，本章只是讲解了各个区域出现内存溢出异常的原因，下一章将详细讲解Java垃圾收集机制为了避免内存溢出异常的出现都做了哪些努力。</p>
<hr>
<h1 id="二、垃圾收集器与内存分配策略"><a href="#二、垃圾收集器与内存分配策略" class="headerlink" title="二、垃圾收集器与内存分配策略"></a>二、垃圾收集器与内存分配策略</h1><h2 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h2><p>​		说起垃圾收集（Garbage Collection,GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分 配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：</p>
<ul>
<li>哪些内存需要回收？ </li>
<li>什么时候回收？ </li>
<li>如何回收？</li>
</ul>
<p>​		经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我 们就需要对这些“自动化”的技术实施必要的监控和调节。 </p>
<p>​		把时间从半个多世纪以前拨回到现在，回到我们熟悉的Java语言。第1章介绍了Java内存运行时区域的各个部分，<strong>其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭</strong>；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个<strong>栈帧中分配多少内存基本上是在类结构确定下来时就已知的</strong>（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此 这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问 题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而<strong>Java堆和方法区</strong>则不一 样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在<strong>程序处于运行期间时才能知道会创建哪些对象</strong>，这部分内存的分配 和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的“内存”分配与回 收也仅指这一部分内存。</p>
<h2 id="2-2对象已死吗"><a href="#2-2对象已死吗" class="headerlink" title="2.2对象已死吗"></a>2.2对象已死吗</h2><p>​		在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一 件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<h3 id="2-2-1引用计数算法"><a href="#2-2-1引用计数算法" class="headerlink" title="2.2.1引用计数算法"></a>2.2.1引用计数算法</h3><p>​		很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，<strong>每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1</strong>；<strong>任何时刻计数器为0的对象就是不可能再被使用的</strong>。作者面试过很多的应届生和一些有多年工作经验的开发人 员，他们对于这个问题给予的都是这个答案。</p>
<p>​		客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言和在游戏脚本领域被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但是，至少主流 的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它<strong>很难解决对象 之间相互循环引用的问题</strong>。 </p>
<p>​		举个简单的例子，请看代码清单2-1中的testGC（）方法：对象objA和objB都有字段 instance，赋值令objA.instance&#x3D;objB及objB.instance&#x3D;objA，除此之外，这两个对象再无任何引 用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的<strong>引用计数都不为0</strong>，于是引用计数算法无法通知GC收集器回收它们。</p>
<p>代码清单2-1 引用计数算法的缺陷</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*testGC（）方法执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span>&#123;</span><br><span class="line"><span class="keyword">public</span> Object instance=<span class="literal">null</span>；</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>；</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[]bigSize=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>*_1MB]；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testGC（）&#123;</span><br><span class="line">ReferenceCountingGC objA=<span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>（）；</span><br><span class="line">ReferenceCountingGC objB=<span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>（）；</span><br><span class="line">objA.instance=objB；</span><br><span class="line">objB.instance=objA；</span><br><span class="line">objA=<span class="literal">null</span>；</span><br><span class="line">objB=<span class="literal">null</span>；</span><br><span class="line"><span class="comment">//假设在这行发生GC,objA和objB是否能被回收？</span></span><br><span class="line">System.gc（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[F u l l G C（S y s t e m）[T e n u r e d：<span class="number">0</span> K-＞<span class="number">2</span> <span class="number">1</span> <span class="number">0</span> K（<span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> K），<span class="number">0.0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> s e c s]4603K-＞210K（19456K），[Perm：2999K-＞</span><br><span class="line">2999K（21248K）]，<span class="number">0.0150007</span> secs][Times：user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</span><br><span class="line">Heap</span><br><span class="line">def <span class="keyword">new</span> <span class="title class_">generation</span> total 9216K,used 82K[<span class="number">0x00000000055e0000</span>，<span class="number">0x0000000005fe0000</span>，<span class="number">0x0000000005fe0000</span>）</span><br><span class="line">Eden space 8192K，<span class="number">1</span>%used[<span class="number">0x00000000055e0000</span>，<span class="number">0x00000000055f4850</span>，<span class="number">0x0000000005de0000</span>）</span><br><span class="line">from space 1024K，<span class="number">0</span>%used[<span class="number">0x0000000005de0000</span>，<span class="number">0x0000000005de0000</span>，<span class="number">0x0000000005ee0000</span>）</span><br><span class="line">to space 1024K，<span class="number">0</span>%used[<span class="number">0x0000000005ee0000</span>，<span class="number">0x0000000005ee0000</span>，<span class="number">0x0000000005fe0000</span>）</span><br><span class="line">tenured generation total 10240K,used 210K[<span class="number">0x0000000005fe0000</span>，<span class="number">0x00000000069e0000</span>，<span class="number">0x00000000069e0000</span>）</span><br><span class="line">the space 10240K，<span class="number">2</span>%used[<span class="number">0x0000000005fe0000</span>，<span class="number">0x0000000006014a18</span>，<span class="number">0x0000000006014c00</span>，<span class="number">0x00000000069e0000</span>）</span><br><span class="line">compacting perm gen total 21248K,used 3016K[<span class="number">0x00000000069e0000</span>，<span class="number">0x0000000007ea0000</span>，<span class="number">0x000000000bde0000</span>）</span><br><span class="line">the space 21248K，<span class="number">14</span>%used[<span class="number">0x00000000069e0000</span>，<span class="number">0x0000000006cd2398</span>，<span class="number">0x0000000006cd2400</span>，<span class="number">0x0000000007ea0000</span>）</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure>

<p>从运行结果中可以清楚看到，GC日志中包含“4603K-＞210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机<strong>并不是通过引用计数算法来判断对象是否存活的</strong>。</p>
<h3 id="2-2-2-可达性分析算法"><a href="#2-2-2-可达性分析算法" class="headerlink" title="2.2.2 可达性分析算法"></a>2.2.2 可达性分析算法</h3><p>​		在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析（ReachabilityAnalysis）来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有<strong>任何引用链相连</strong>（用图论的话来说，就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。如图2-1所示，对象object5、object6、object7虽然互相有关联，但是它们到GCRoots是不可达的，所以它们将会被判定为是可回收的对象。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011130481.png" style="zoom:67%;" /></figure>

<p>在Java语言中，可作为GC Roots的对象包括下面几种： </p>
<ul>
<li><strong>虚拟机栈（栈帧中的本地变量表）中引用的对象。</strong> </li>
<li><strong>方法区中类静态属性引用的对象。</strong> </li>
<li><strong>方法区中常量引用的对象。</strong> </li>
<li><strong>本地方法栈中JNI（即一般说的Native方法）引用的对象。</strong></li>
</ul>
<h3 id="2-2-3引用的类型"><a href="#2-2-3引用的类型" class="headerlink" title="2.2.3引用的类型"></a>2.2.3引用的类型</h3><p>​		在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似“Objectobj&#x3D;newObject（）”这类的引用，<strong>只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</strong></li>
<li><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在<strong>系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。</strong>如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li>
<li><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，<strong>无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ul>
<h3 id="2-2-4-生存还是死亡"><a href="#2-2-4-生存还是死亡" class="headerlink" title="2.2.4 生存还是死亡"></a>2.2.4 生存还是死亡</h3><p>​		即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GCRoots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。<strong>当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过</strong>，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>​		如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize（）方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。<strong>finalize（）方法是对象逃脱死亡命运的最后一次机会</strong>，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
<p>代码清单2-2 一次对象自我拯救的演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此代码演示了两点：</span></span><br><span class="line"><span class="comment">*1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">*2.这种自救的机会只有一次，因为一个对象的finalize（）方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK=<span class="literal">null</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> isAlive（）&#123;</span><br><span class="line">System.out.println（<span class="string">&quot;yes,i am still alive：）&quot;</span>）；</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> finalize（）<span class="keyword">throws</span> Throwable&#123;</span><br><span class="line"><span class="built_in">super</span>.finalize（）；</span><br><span class="line">System.out.println（<span class="string">&quot;finalize mehtod executed！&quot;</span>）；</span><br><span class="line">FinalizeEscapeGC.SAVE_HOOK=<span class="built_in">this</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）<span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">SAVE_HOOK=<span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>（）；</span><br><span class="line"><span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">SAVE_HOOK=<span class="literal">null</span>；</span><br><span class="line">System.gc（）；</span><br><span class="line"><span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">Thread.sleep（<span class="number">500</span>）；</span><br><span class="line"><span class="keyword">if</span>（SAVE_HOOK！=<span class="literal">null</span>）&#123;</span><br><span class="line">SAVE_HOOK.isAlive（）；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println（<span class="string">&quot;no,i am dead：（&quot;</span>）；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">SAVE_HOOK=<span class="literal">null</span>；</span><br><span class="line">System.gc（）；</span><br><span class="line"><span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">Thread.sleep（<span class="number">500</span>）；</span><br><span class="line"><span class="keyword">if</span>（SAVE_HOOK！=<span class="literal">null</span>）&#123;</span><br><span class="line">SAVE_HOOK.isAlive（）；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println（<span class="string">&quot;no,i am dead：（&quot;</span>）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize mehtod executed！</span><br><span class="line">yes,i am still alive：）</span><br><span class="line">no,i am dead：（</span><br></pre></td></tr></table></figure>

<p>​		从代码清单2-2的运行结果可以看出，SAVE_HOOK对象的finalize（）方法确实被GC收集器触发过，并且在被收集前成功逃脱了。</p>
<p>​		另外一个值得注意的地方是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize（）方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize（）方法不会被再次执行，因此第二段代码的自救行动失败了。</p>
<p>​		需要特别说明的是，上面关于对象死亡时finalize（）方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C&#x2F;C++中的析构函数，而是Java刚诞生时为了使C&#x2F;C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize（）能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言中有这个方法的存在。</p>
<h3 id="2-2-5-回收方法区"><a href="#2-2-5-回收方法区" class="headerlink" title="2.2.5 回收方法区"></a>2.2.5 回收方法区</h3><p>​		永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。</p>
<p>​		常量池中的其他类（接口）、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li><strong>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</strong></li>
<li><strong>加载该类的ClassLoader已经被回收。</strong></li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</strong></li>
</ul>
<p>​		虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，<strong>不使用了就必然会回收</strong>。是否对类进行回收，HotSpot虚拟机提供了**-Xnoclassgc参数进行控制**，还可以使用-verbose：class以及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p>
<p>​		在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h2 id="2-3-垃圾收集算法"><a href="#2-3-垃圾收集算法" class="headerlink" title="2.3 垃圾收集算法"></a>2.3 垃圾收集算法</h2><h3 id="3-3-1-标记-清除算法"><a href="#3-3-1-标记-清除算法" class="headerlink" title="3.3.1 标记-清除算法"></a>3.3.1 标记-清除算法</h3><p>​		最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过程如图2-2所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011300203.png" style="zoom:67%;" /></figure>

<h3 id="2-3-2-复制算法"><a href="#2-3-2-复制算法" class="headerlink" title="2.3.2 复制算法"></a>2.3.2 复制算法</h3><p>​		为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。复制算法的执行过程如图2-3所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011302658.png" style="zoom:67%;" /></figure>

<p>​		现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象<strong>98%是“朝生夕死”的</strong>，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块<strong>较大的Eden空间和两块较小的Survivor空间</strong>，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1</strong>，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保</strong>（HandlePromotion）。</p>
<p>​		内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果<strong>另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</strong></p>
<h3 id="2-3-3-标记-整理算法"><a href="#2-3-3-标记-整理算法" class="headerlink" title="2.3.3 标记-整理算法"></a>2.3.3 标记-整理算法</h3><p>​		复制收集算法在<strong>对象存活率较高时就要进行较多的复制操作，效率将会变低</strong>。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中<strong>所有对象都100%存活的极端情况</strong>，所以在老年代一般不能直接选用这种算法。</p>
<p>​		根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图2-4所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011307238.png" style="zoom:67%;" /></figure>

<h3 id="2-3-4-分代收集算法"><a href="#2-3-4-分代收集算法" class="headerlink" title="2.3.4 分代收集算法"></a>2.3.4 分代收集算法</h3><p>​		当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<h2 id="2-4-HotSpot的算法实现"><a href="#2-4-HotSpot的算法实现" class="headerlink" title="2.4 HotSpot的算法实现"></a>2.4 HotSpot的算法实现</h2><h3 id="2-4-1-枚举根节点"><a href="#2-4-1-枚举根节点" class="headerlink" title="2.4.1 枚举根节点"></a>2.4.1 枚举根节点</h3><p>​		从可达性分析中从GCRoots节点找引用链这个操作为例，可作为GCRoots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p>
<p>​		另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保<strong>一致性的快照</strong>中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被<strong>冻结在某个时间点</strong>上，<strong>不可以出现分析过程中对象引用关系还在不断变化的情况</strong>，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“StopTheWorld”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<p>​		由于目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的的，在类加载完成的时候，<strong>HotSpot就把对象内什么偏移量上是什么类型的数据计算出来</strong>，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p>
<h3 id="2-4-2-安全点"><a href="#2-4-2-安全点" class="headerlink" title="2.4.2 安全点"></a>2.4.2 安全点</h3><p>​		在OopMap的协助下，HotSpot可以快速且准确地完成GCRoots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要<strong>大量的额外空间</strong>，这样GC的空间成本将会变得很高。</p>
<p>​		实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在<strong>所有地方都能停顿下来开始GC</strong>，<strong>只有在到达安全点时才能暂停</strong>。<strong>Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷</strong>。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如<strong>方法调用、循环跳转、异常跳转</strong>等，所以具有这些功能的指令才会产生Safepoint。</p>
<p>​		对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（PreemptiveSuspension）和主动式中断（VoluntarySuspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p>
<p>​		而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地<strong>设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</strong>轮询标志的地方和安全点是重合的，另外再<strong>加上创建对象需要分配内存的地方</strong>。</p>
<h3 id="2-4-3-安全区域"><a href="#2-4-3-安全区域" class="headerlink" title="2.4.3 安全区域"></a>2.4.3 安全区域</h3><p>​		使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的<strong>程序不执行就是没有分配CPU时间</strong>，典型的例子就是<strong>线程处于Sleep状态或者Blocked状态</strong>，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（SafeRegion）来解决。</p>
<p>​		安全区域是指在一段代码片段之中，<strong>引用关系不会发生变化</strong>。在这个区域中的任意地方开始GC都是安全的。我们也可以把SafeRegion看做是被扩展了的Safepoint。在线程执行到SafeRegion中的代码时，首先标识自己已经进入了SafeRegion，那样，当在这段时间里JVM要发起GC时，<strong>就不用管标识自己为SafeRegion状态的线程了</strong>。<strong>在线程要离开SafeRegion时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程）</strong>，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开SafeRegion的信号为止。		到此，笔者简要地介绍了HotSpot虚拟机如何去发起内存回收的问题，但是虚拟机如何具体地进行内存回收动作仍然未涉及，因为内存回收如何进行是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器。下面继续来看HotSpot中有哪些GC收集器。</p>
<h2 id="2-5-垃圾收集器"><a href="#2-5-垃圾收集器" class="headerlink" title="2.5 垃圾收集器"></a>2.5 垃圾收集器</h2><p>​		如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK1.7Update14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），这个虚拟机包含的所有收集器如图2-5所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011402440.png" style="zoom:67%;" /></figure>

<p>​		图2-5展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来笔者将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器，了解它们的部分运作细节。在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。</p>
<h3 id="2-5-1-Serial收集器"><a href="#2-5-1-Serial收集器" class="headerlink" title="2.5.1 Serial收集器"></a>2.5.1 Serial收集器</h3><p>​		Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个<strong>单线程的收集器</strong>，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“StopTheWorld”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。读者不妨试想一下，要是你的计算机每运行一个小时就会暂停响应5分钟，你会有什么样的心情？图2-6示意了Serial&#x2F;SerialOld收集器的运行过程。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011403493.png" style="zoom:67%;" /></figure>

<h3 id="2-5-2-ParNew收集器"><a href="#2-5-2-ParNew收集器" class="headerlink" title="2.5.2 ParNew收集器"></a>2.5.2 ParNew收集器</h3><p>​		ParNew收集器其实就是Serial收集器的<strong>多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如图2-7所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011403381.png" style="zoom:67%;" /></figure>

<p>​		ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，<strong>目前只有它能与CMS收集器配合工作</strong>。在JDK1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（ConcurrentMarkSweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，<strong>就是做到了在你的妈妈打扫房间的时候你还能一边往地上扔纸屑</strong>。</p>
<p>​		不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器ParallelScavenge配合工作，<strong>所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个</strong>。ParNew收集器也是使用-XX：+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX：+UseParNewGC选项来强制指定它。</p>
<p>​		ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<h3 id="2-5-3-Parallel-Scavenge收集器"><a href="#2-5-3-Parallel-Scavenge收集器" class="headerlink" title="2.5.3 Parallel Scavenge收集器"></a>2.5.3 Parallel Scavenge收集器</h3><p>​		ParallelScavenge收集器是一个新生代收集器，它也是<strong>使用复制算法</strong>的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？</p>
<p>​		ParallelScavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地<strong>缩短垃圾收集时用户线程的停顿时间</strong>，而ParallelScavenge收集器的<strong>目标则是达到一个可控制的吞吐量（Throughput）</strong>。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即<strong>吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）</strong>，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p>​		停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>​		ParallelScavenge收集器提供了两个参数用于精确控制吞吐量，分别是<strong>控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数</strong>。</p>
<p>​		MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，<strong>GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的</strong>：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致<strong>垃圾收集发生得更频繁</strong>一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。<strong>停顿时间的确在下降，但吞吐量也降下来了</strong>。</p>
<p>​		GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1&#x2F;（1+19）），默认值为99，就是允许最大1%（即1&#x2F;（1+99））的垃圾收集时间。</p>
<p>​		由于与吞吐量关系密切，ParallelScavenge收集器也经常称为“<strong>吞吐量优先”收集器</strong>。除上述两个参数之外，ParallelScavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为<strong>GC自适应的调节策略（GCErgonomics）</strong>。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用ParallelScavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。</p>
<h3 id="2-5-4-Serial-Old收集器"><a href="#2-5-4-Serial-Old收集器" class="headerlink" title="2.5.4 Serial Old收集器"></a>2.5.4 Serial Old收集器</h3><p>​		SerialOld是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“<strong>标记-整理</strong>”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：</p>
<ul>
<li>一种用途是在JDK1.5以及之前的版本中与<strong>Parallel-Scavenge收集器搭配使用</strong>。</li>
<li>另一种用途就是作为<strong>CMS收集器的后备预案</strong>，在并发收集发生ConcurrentModeFailure时使用。</li>
</ul>
<p>这两点都将在后面的内容中详细讲解。SerialOld收集器的工作过程如图2-8所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011403359.png" style="zoom:67%;" /></figure>

<h3 id="2-5-5-Parallel-Old收集器"><a href="#2-5-5-Parallel-Old收集器" class="headerlink" title="2.5.5 Parallel Old收集器"></a>2.5.5 Parallel Old收集器</h3><p>​		ParallelOld是<strong>Parallel Scavenge收集器的老年代版本</strong>，使用<strong>多线程和“标记-整理”算法</strong>。这个收集器是在JDK1.6中才开始提供的，在此之前，新生代的ParallelScavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了ParallelScavenge收集器，老年代除了SerialOld（PSMarkSweep）收集器外别无选择（还记得上面说过<strong>ParallelScavenge收集器无法与CMS收集器配合</strong>工作吗？）。由于老年代SerialOld收集器在服务端应用性能上的“拖累”，使用了ParallelScavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。</p>
<p>​		直到ParallelOld收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑ParallelScavenge加ParallelOld收集器。ParallelOld收集器的工作过程如图2-9所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011406506.png" style="zoom:67%;" /></figure>

<h3 id="2-5-6-CMS收集器"><a href="#2-5-6-CMS收集器" class="headerlink" title="2.5.6 CMS收集器"></a>2.5.6 CMS收集器</h3><p>​		CMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“MarkSweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li><strong>初始标记（CMSinitialmark）</strong></li>
<li><strong>并发标记（CMSconcurrentmark）</strong></li>
<li><strong>重新标记（CMSremark）</strong></li>
<li><strong>并发清除（CMSconcurrentsweep）</strong></li>
</ul>
<p>​		其中，<strong>初始标记、重新标记这两个步骤仍然需要“StopTheWorld”</strong>。初始标记仅仅只是<strong>标记一下GCRoots能直接关联到的对象</strong>，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是<strong>为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的<strong>停顿时间一般会比初始标记阶段稍长一些</strong>，<strong>但远比并发标记的时间短</strong>。由于整个过程中<strong>耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作</strong>，所以，从总体上来说，CMS收集器的<strong>内存回收过程是与用户线程</strong>一起<strong>并发执行</strong>的。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011421878.png" style="zoom:67%;" /></figure>

<p>​		CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：<strong>并发收集、低停顿</strong>，Sun公司的一些官方文档中也称之为并发低停顿收集器（ConcurrentLowPauseCollector）。但是CMS还远达不到完美的程度，它有以下3个明显的缺点：</p>
<ul>
<li><strong>CMS收集器对CPU资源非常敏感</strong>。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为<strong>占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低</strong>。CMS默认启动的回收线程数是（CPU数量+3）&#x2F;4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（IncrementalConcurrentMarkSweep&#x2F;i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实践证明，增量时的CMS收集器效果很一般，在目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。</li>
<li><strong>CMS收集器无法处理浮动垃圾（FloatingGarbage）</strong>，可能出现“ConcurrentModeFailure”失败而导致另一次FullGC的产生。由于<strong>CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。</strong>这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX：<ul>
<li>CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“ConcurrentModeFailure”失败，这时虚拟机将启动后备预案：临时启用SerialOld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX：CMSInitiatingOccupancyFraction设置得太高很容易导致大量“ConcurrentModeFailure”失败，性能反而降低。</li>
</ul>
</li>
<li>还有最后一个缺点，在本节开头说过，<strong>CMS是一款基于“标记—清除”算法实现的收集器</strong>，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着<strong>收集结束时会有大量空间碎片产生</strong>。<strong>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象****，</strong>不得不提前触发一次FullGC**。为了解决这个问题，CMS收集器提供了一个-XX：<ul>
<li>+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
<li>虚拟机设计者还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的FullGC后，跟着来一次带压缩的（默认值为0，表示每次进入FullGC时都进行碎片整理）。</li>
</ul>
</li>
</ul>
<h3 id="2-5-7-G1收集器"><a href="#2-5-7-G1收集器" class="headerlink" title="2.5.7 G1收集器"></a>2.5.7 G1收集器</h3><p>​		G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，早在JDK1.7刚刚确立项目目标，Sun公司给出的JDK1.7RoadMap里面，它就被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。从JDK6u14中开始就有EarlyAccess版本的G1收集器供开发人员实验、试用，由此开始G1收集器的“Experimental”状态持续了数年时间，直至JDK7u4，Sun公司才认为它达到足够成熟的商用程度，移除了“Experimental”的标识。</p>
<p>​		G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。</p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li><strong>分代收集</strong>：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li>
<li><strong>空间整合</strong>：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<p>​		在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，<strong>它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合</strong>。</p>
<p>​		G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。<strong>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了<strong>G1收集器在有限的时间内可以获取尽可能高的收集效率</strong>。</p>
<p>​		G1把内存“化整为零”的思路，理解起来似乎很容易，但其中的实现细节却远远没有想象中那样简单，否则也不会从2004年Sun实验室发表第一篇G1的论文开始直到今天（将近10年时间）才开发出G1的商用版。笔者以一个细节为例：把Java堆分为多个Region后，垃圾收集是否就真的能以Region为单位进行了？听起来顺理成章，再仔细想想就很容易发现问题所在：<strong>Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被本Region中的其他对象引用，而是可以与整个Java堆任意的对象发生引用关系。那在做可达性判定确定对象是否存活的时候，岂不是还得扫描整个Java堆才能保证准确性？</strong>这个问题其实并非在G1中才有，只是在G1中更加突出而已。在以前的分代收集中，新生代的规模一般都比老年代要小许多，新生代的收集也比老年代要频繁许多，那回收新生代中的对象时也面临相同的问题，如果回收新生代时也不得不同时扫描老年代的话，那么MinorGC的效率可能下降不少。</p>
<p>​		在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用RememberedSet来避免全堆扫描的。G1中每个Region都有一个与之对应的RememberedSet，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个WriteBarrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的RememberedSet之中。当进行内存回收时，在GC根节点的枚举范围中加入RememberedSet即可保证不对全堆扫描也不会有遗漏。</p>
<p>​		如果不计算维护RememberedSet的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li><strong>初始标记（InitialMarking）</strong></li>
<li><strong>并发标记（ConcurrentMarking）</strong></li>
<li><strong>最终标记（FinalMarking）</strong></li>
<li><strong>筛选回收（LiveDataCountingandEvacuation）</strong></li>
</ul>
<p>​		对CMS收集器运作过程熟悉的读者，一定已经发现G1的前几个步骤的运作过程和CMS有很多相似之处。<strong>初始标记阶段仅仅只是标记一下GCRoots能直接关联到的对象</strong>，并且修改TAMS（NextTopatMarkStart）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要<strong>停顿线程</strong>，<strong>但耗时很短</strong>。<strong>并发标记阶段是从GCRoot开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行</strong>。<strong>而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</strong>，虚拟机将这段时间对象变化记录在线程RememberedSetLogs里面，最终标记阶段需要把RememberedSetLogs的数据合并到RememberedSet中，这阶段需要<strong>停顿线程</strong>，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，<strong>根据用户所期望的GC停顿时间来制定回收计划</strong>，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。通过图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011442335.png" style="zoom:67%;" /></figure>

<p>​		由于目前G1成熟版本的发布时间还很短，G1收集器几乎可以说还没有经过实际应用的考验，网络上关于G1收集器的性能测试也非常贫乏，到目前为止，笔者还没有搜索到有关的生产环境下的性能测试报告。强调“生产环境下的测试报告”是因为对于垃圾收集器来说，仅仅通过简单的Java代码写个Microbenchmark程序来创建、移除Java对象，再用-XX：+PrintGCDetails等参数来查看GC日志是很难做到准确衡量其性能的。因此，关于G1收集器的性能部分，笔者引用了Sun实验室的论文《Garbage-FirstGarbageCollection》中的一段测试数据。</p>
<p>​		Sun给出的Benchmark的执行硬件为SunV880服务器（8×750MHzUltraSPARCIIICPU、32G内存、Solaris10操作系统）。执行软件有两个，分别为SPECjbb（模拟商业数据库应用，堆中存活对象约为165MB，结果反映吐量和最长事务处理时间）和telco（模拟电话应答服务应用，堆中存活对象约为100MB，结果反映系统能支持的最大吞吐量）。为了便于对比，还收集了一组使用ParNew+CMS收集器的测试数据。所有测试都配置为与CPU数量相同的8条GC线程。</p>
<p>​		在更大规模的生产环境下，笔者引用一段在StackOverflow.com上看到的经验与读者分享：“我在一个真实的、较大规模的应用程序中使用过G1：大约分配有60～70GB内存，存活对象大约在20～50GB之间。服务器运行Linux操作系统，JDK版本为6u22。G1与PS&#x2F;PSOld相比，最大的好处是停顿时间更加可控、可预测，如果我在PS中设置一个很低的最大允许GC时间，譬如期望50毫秒内完成GC（-XX：MaxGCPauseMillis&#x3D;50），但在65GB的Java堆下有可能得到的直接结果是一次长达30秒至2分钟的漫长的Stop-The-World过程；而G1与CMS相比，<strong>虽然它们都立足于低停顿时间</strong>，CMS仍然是我现在的选择，但是随着Oracle对G1的持续改进，我相信G1会是最终的胜利者。如果你现在采用的收集器没有出现问题，那就没有任何理由现在去选择G1，<strong>如果你的应用追求低停顿，那G1现在已经可以作为一个可尝试的选择，如果你的应用追求吞吐量，那G1并不会为你带来什么特别的好处</strong>”。</p>
<h2 id="2-6-内存分配与回收策略"><a href="#2-6-内存分配与回收策略" class="headerlink" title="2.6 内存分配与回收策略"></a>2.6 内存分配与回收策略</h2><p>​		Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存的那点事儿。</p>
<p>​		对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<p>​		接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。本节下面的代码在测试时使用Client模式虚拟机运行，没有手工指定收集器组合，换句话说，验证的是在使用Serial&#x2F;SerialOld收集器下（ParNew&#x2F;SerialOld收集器组合的规则也基本一致）的内存分配和回收的策略。读者不妨根据自己项目中使用的收集器写一些程序去验证一下使用其他几种收集器的内存分配策略。</p>
<h3 id="2-6-1-对象优先在Eden分配"><a href="#2-6-1-对象优先在Eden分配" class="headerlink" title="2.6.1 对象优先在Eden分配"></a>2.6.1 对象优先在Eden分配</h3><p>​		<strong>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。</strong></p>
<p>​       虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p>
<p>​		新生代GC（MinorGC）：指发生在新生代的垃圾收集动作，因为<strong>Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。</strong></p>
<p>​		老年代GC（MajorGC&#x2F;FullGC）：指<strong>发生在老年代的GC</strong>，出现了MajorGC，经常会伴随至少一次的MinorGC（但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）。<strong>MajorGC的速度一般会比MinorGC慢10倍以上。</strong></p>
<h3 id="2-6-2-大对象直接进入老年代"><a href="#2-6-2-大对象直接进入老年代" class="headerlink" title="2.6.2 大对象直接进入老年代"></a>2.6.2 大对象直接进入老年代</h3><p>​		所谓的大对象是指，<strong>需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组</strong>（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），<strong>经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</strong></p>
<p>​		虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。<strong>这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制</strong>（复习一下：新生代采用复制算法收集内存）。</p>
<h3 id="2-6-3-长期存活的对象将进入老年代"><a href="#2-6-3-长期存活的对象将进入老年代" class="headerlink" title="2.6.3 长期存活的对象将进入老年代"></a>2.6.3 长期存活的对象将进入老年代</h3><p>​		既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。<strong>如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</strong>对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuring-Threshold设置。</p>
<h3 id="2-6-4-动态对象年龄判定"><a href="#2-6-4-动态对象年龄判定" class="headerlink" title="2.6.4 动态对象年龄判定"></a>2.6.4 动态对象年龄判定</h3><p>​		为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</strong></p>
<h3 id="2-6-5-空间分配担保"><a href="#2-6-5-空间分配担保" class="headerlink" title="2.6.5 空间分配担保"></a>2.6.5 空间分配担保</h3><p>​		在发生MinorGC之前，<strong>虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那么MinorGC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查<strong>老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</strong>，<strong>如果大于，将尝试着进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次FullGC</strong>。</p>
<p>​		下面解释一下“冒险”是冒了什么风险，前面提到过，<strong>新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</strong>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，<strong>所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值</strong>，与老年代的剩余空间进行比较，决定是否进行FullGC来让老年代腾出更多空间。</p>
<p>​		取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次MinorGC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（HandlePromotionFailure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次FullGC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免FullGC过于频繁，</p>
<h2 id="2-7-本章小结"><a href="#2-7-本章小结" class="headerlink" title="2.7 本章小结"></a>2.7 本章小结</h2><p>​		本章介绍了垃圾收集的算法、几款JDK1.7中提供的垃圾收集器特点以及运作原理。通过代码实例验证了Java虚拟机中自动内存分配及回收的主要规则。</p>
<p>​		内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能。没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。因此，学习虚拟机内存知识，如果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。在接下来的两章中，作者将会介绍内存分析的工具和调优的一些具体案例。</p>
<hr>
<h1 id="三、虚拟机性能监控与故障处理工具"><a href="#三、虚拟机性能监控与故障处理工具" class="headerlink" title="三、虚拟机性能监控与故障处理工具"></a>三、虚拟机性能监控与故障处理工具</h1><h2 id="3-1系统概述"><a href="#3-1系统概述" class="headerlink" title="3.1系统概述"></a>3.1系统概述</h2><p>​		理论总是作为指导实践的工具，能把这些知识应用到实际工作中才是我们的最终目的。接下来的两章，我们将从实践的角度去了解虚拟机内存管理的世界。</p>
<p>​		给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照（threaddump&#x2F;javacore文件）、堆转储快照（heapdump&#x2F;hprof文件）等。</p>
<p>​		经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位解决问题的速度，但在学习工具前，也应当意识到工具永远都是知识技能的一层包装，没有什么工具是“秘密武器”，不可能学会了就能包治百病。</p>
<h2 id="3-2-JDK的命令行工具"><a href="#3-2-JDK的命令行工具" class="headerlink" title="3.2 JDK的命令行工具"></a>3.2 JDK的命令行工具</h2><h3 id="3-2-1-jps：虚拟机进程状况工具"><a href="#3-2-1-jps：虚拟机进程状况工具" class="headerlink" title="3.2.1 jps：虚拟机进程状况工具"></a>3.2.1 jps：虚拟机进程状况工具</h3><p>​		jps可以列出<strong>正在运行的虚拟机进程</strong>，<strong>并显示虚拟机执行主类（MainClass,main（）函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LocalVirtualMachineIdentifier,LVMID）</strong>。虽然功能比较单一，但它是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的<strong>LVMID来确定要监控的是哪一个虚拟机进程</strong>。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（ProcessIdentifier,PID）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。</p>
<p>jsp命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps[options][hostid]</span><br></pre></td></tr></table></figure>

<p>jps执行样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D：\Develop\Java\jdk1.6.0_21\bin＞jps-l</span><br><span class="line">2388 D：\Develop\glassfish\bin\..\modules\admin-cli.jar</span><br><span class="line">2764 com.sun.enterprise.glassfish.bootstrap.ASMain</span><br><span class="line">3788 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure>

<p>​		jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。jps的其他常用选项见图。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011535785.png" style="zoom:67%;" /></figure>

<h3 id="3-2-2-jstat：虚拟机统计信息监视工具"><a href="#3-2-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="3.2.2 jstat：虚拟机统计信息监视工具"></a>3.2.2 jstat：虚拟机统计信息监视工具</h3><p>​		jstat（JVMStatisticsMonitoringTool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以<strong>显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</strong>，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p>
<p>jstat命令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat[option vmid[interval[s|ms][count]]]</span><br></pre></td></tr></table></figure>

<p>对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol：][//]lvmid[@hostname[：port]/servername]</span><br></pre></td></tr></table></figure>

<p>选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及作用请参考图中的描述。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205011541738.png" style="zoom:67%;" /></figure>

<p>​		jstat监视选项众多，囿于版面原因无法逐一演示，这里仅举监视一台刚刚启动的GlassFishv3服务器的内存状况的例子来演示如何查看监视结果。监视参数与输出结果如代码清单所示。</p>
<p>代码清单3-1 jstat执行样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D：\Develop\Java\jdk1.6.0_21\bin＞jstat-gcutil 2764</span><br><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</span><br><span class="line">0.00 0.00 6.20 41.42 47.20 16 0.105 3 0.472 0.577</span><br></pre></td></tr></table></figure>

<p>​		查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了6.2%的空间，两个Survivor区（S0、S1，表示Survivor0、Survivor1）里面都是空的，老年代（O，表示Old）和永久代（P，表示Permanent）则分别使用了41.42%和47.20%的空间。程序运行以来共发生MinorGC（YGC，表示YoungGC）16次，总耗时0.105秒，发生FullGC（FGC，表示FullGC）3次，FullGC总耗时（FGCT，表示FullGCTime）为0.472秒，所有GC总耗时（GCT，表示GCTime）为0.577秒。</p>
<p>​		使用jstat工具在纯文本状态下监视虚拟机状态的变化，确实不如后面将会提到的VisualVM等可视化的监视工具直接以图表展现那样直观。但许多服务器管理员都习惯了在文本控制台中工作，直接在控制台中使用jstat命令依然是一种常用的监控方式。</p>
<h3 id="3-2-3-jinfo：Java配置信息工具"><a href="#3-2-3-jinfo：Java配置信息工具" class="headerlink" title="3.2.3 jinfo：Java配置信息工具"></a>3.2.3 jinfo：Java配置信息工具</h3><p>​		jinfo（ConfigurationInfoforJava）的作用是实时地查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，<strong>但如果想知道未被显式指定的参数的系统默认值</strong>，除了去找资料外，就只能使用jinfo的-flag选项进行查询了（如果只限于JDK1.6或以上版本的话，使用java-XX：+PrintFlagsFinal查看参数默认值也是一个很好的选择），jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties（）的内容打印出来。这个命令在JDK1.5时期已经随着Linux版的JDK发布，当时只提供了信息查询的功能，JDK1.6之后，jinfo在Windows和Linux平台都有提供，并且加入了运行期修改参数的能力，可以使用-flag[+|-]name或者-flagname&#x3D;value修改一部分运行期可写的虚拟机参数值。JDK1.6中，jinfo对于Windows平台功能仍然有较大限制，只提供了最基本的-flag选项。</p>
<p>jinfo命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo[option]pid</span><br></pre></td></tr></table></figure>

<p>执行样例：查询CMSInitiatingOccupancyFraction参数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C：\＞jinfo-flag CMSInitiatingOccupancyFraction 1444</span><br><span class="line">-XX：CMSInitiatingOccupancyFraction=85</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-jmap：Java内存映像工具"><a href="#3-2-4-jmap：Java内存映像工具" class="headerlink" title="3.2.4 jmap：Java内存映像工具"></a>3.2.4 jmap：Java内存映像工具</h3><p>​		jmap（MemoryMapforJava）命令用于生成堆转储快照（一般称为heapdump或dump文件）。如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如在第2章中用过的-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。</p>
<p>​		jmap的作用并<strong>不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器</strong>等。</p>
<p>​		和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux&#x2F;Solaris下使用。</p>
<p>jmap命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap[option]vmid</span><br></pre></td></tr></table></figure>

<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021002942.png" style="zoom:67%;" /></figure>

<p>使用jmap生成dump文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C：\Users\IcyFenix＞jmap-dump：format=b,file=eclipse.bin 3500</span><br><span class="line">Dumping heap to C：\Users\IcyFenix\eclipse.bin……</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>

<h3 id="3-2-5-jhat：虚拟机堆转储快照分析工具"><a href="#3-2-5-jhat：虚拟机堆转储快照分析工具" class="headerlink" title="3.2.5 jhat：虚拟机堆转储快照分析工具"></a>3.2.5 jhat：虚拟机堆转储快照分析工具</h3><p>​		SunJDK提供jhat（JVMHeapAnalysisTool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。不过实事求是地说，在实际工作中，除非笔者手上真的没有别的工具可用，否则一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器[1]上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；另一个原因是jhat的分析功能相对来说比较简陋，后文将会介绍到的VisualVM，以及专业用于分析dump文件的EclipseMemoryAnalyzer、IBMHeapAnalyzer[2]等工具，都能实现比jhat更强大更专业的分析功能。</p>
<p>使用jhat分析dump文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C：\Users\IcyFenix＞jhat eclipse.bin</span><br><span class="line">Reading from eclipse.bin……</span><br><span class="line">Dump file created Fri Nov 19 22：07：21 CST 2010</span><br><span class="line">Snapshot read,resolving……</span><br><span class="line">Resolving 1225951 objects……</span><br><span class="line">Chasing references,expect 245 dots……</span><br><span class="line">Eliminating duplicate references……</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<h3 id="3-2-6-jstack：Java堆栈跟踪工具"><a href="#3-2-6-jstack：Java堆栈跟踪工具" class="headerlink" title="3.2.6 jstack：Java堆栈跟踪工具"></a>3.2.6 jstack：Java堆栈跟踪工具</h3><p>​		jstack（StackTraceforJava）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p>
<p>jstack命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack[option]vmid</span><br></pre></td></tr></table></figure>

<p>​		option选项的合法值与具体含义</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021017872.png" style="zoom:67%;" /></figure>

<p>使用jstack查看线程堆栈，例子中的3500是通过jps命令查询到的LVMID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C：\Users\IcyFenix＞jstack-l 3500</span><br><span class="line">2010-11-19 23：11：26</span><br><span class="line">Full thread dump Java HotSpot（TM）64-Bit Server VM（17.1-b03 mixed mode）：</span><br><span class="line">&quot;[ThreadPool Manager]-Idle Thread&quot;daemon prio=6 tid=0x0000000039dd4000 nid=0xf50 in Object.wait（）[0x000000003c96f000]</span><br><span class="line">java.lang.Thread.State：WAITING（on object monitor）</span><br><span class="line">at java.lang.Object.wait（Native Method）</span><br><span class="line">-waiting on＜0x0000000016bdcc60＞（a org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor）</span><br><span class="line">at java.lang.Object.wait（Object.java：485）</span><br><span class="line">at org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor.run（Executor.java：106）</span><br><span class="line">-locked＜0x0000000016bdcc60＞（a org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor）</span><br><span class="line">Locked ownable synchronizers：</span><br><span class="line">-None</span><br></pre></td></tr></table></figure>

<h2 id="3-3-JDK的可视化工具"><a href="#3-3-JDK的可视化工具" class="headerlink" title="3.3 JDK的可视化工具"></a>3.3 JDK的可视化工具</h2><p>​		JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole和VisualVM，这两个工具是JDK的正式成员，没有被贴上“unsupportedandexperimental”的标签。</p>
<p>​		其中JConsole是在JDK1.5时期就已经提供的虚拟机监控工具，而VisualVM在JDK1.6Update7中才首次发布，现在已经成为Sun（Oracle）主力推动的多合一故障处理工具，并且已经从JDK中分离出来成为可以独立发展的开源项目。</p>
<p>​		为了避免本节的讲解成为对软件说明文档的简单翻译，笔者准备了一些代码样例，都是笔者特意编写的“反面教材”。后面将会使用这两款工具去监控、分析这几段代码存在的问题，算是本节简单的实战分析。读者可以把在可视化工具观察到的数据、现象，与前面两章中讲解的理论知识互相印证。</p>
<h3 id="3-3-1-JConsole：Java监视与管理控制台"><a href="#3-3-1-JConsole：Java监视与管理控制台" class="headerlink" title="3.3.1 JConsole：Java监视与管理控制台"></a>3.3.1 JConsole：Java监视与管理控制台</h3><p>​		JConsole（JavaMonitoringandManagementConsole）是一种基于JMX的可视化监视、管理工具。它管理部分的功能是针对JMXMBean进行管理，由于MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问，所以本节将会着重介绍JConsole监视部分的功能。</p>
<p>启动JConsole</p>
<p>通过JDK&#x2F;bin目录下的“”启动JConsole后，将自动搜索出本机运行的所有虚拟机进程，不需要用户自己再使用jps来查询了，Idea中在Jshell中输入命令启动Jconsole，如图所示。双击选择其中一个进程即可开始监控，也可以使用下面的“远程进程”功能来连接远程服务器，对远程虚拟机进行监控。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021050948.png" style="zoom: 67%;" /></figure>

<p>双击它进入JConsole主 界面，可以看到主界面里共包括“概述”、“内存”、“线程”、“类”、“VM摘要”、“MBean”6个 页签，如图所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021054904.png" style="zoom: 67%;" /></figure>

<p>“概览”页签显示的是整个虚拟机主要运行数据的概览，其中包括“堆内存使用情况”、 “线程”、“类”、“CPU使用情况”4种信息的曲线图，这些曲线图是后面“内存”、“线程”、 “类”页签的信息汇总，具体内容将在后面介绍。</p>
<h4 id="3-3-1-1内存监控"><a href="#3-3-1-1内存监控" class="headerlink" title="3.3.1.1内存监控"></a>3.3.1.1<strong>内存监控</strong></h4><p>“内存”页签相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存（Java堆和永久代）的变化趋势。我们通过运行代码清单4-8中的代码来体验一下它的监视功能。运行时设置的虚拟机参数为：-Xms100m-Xmx100m-XX：+UseSerialGC，这段代码的作用是以64KB&#x2F;50毫秒的速度往Java堆中填充数据，一共填充1000次，使用JConsole的“内存”页签进行监视，观察曲线和柱状指示图的变化。</p>
<figure class="figure"><img src="../../public/img/jvm4-7.png" style="zoom: 67%;" /></figure>

<p>JConsole监视代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *内存占位符对象，一个OOMObject大约占64KB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[]placeholder=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fillHeap</span><span class="params">(<span class="type">int</span> num)</span><span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        List&lt;OOMObject&gt;list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line"><span class="comment">//稍作延时，令监视曲线的变化更加明显</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        fillHeap(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	程序运行后，在“内存”页签中可以看到内存池Eden区的运行趋势呈现折线状，如图所示。而监视范围扩大至整个堆后，会发现曲线是一条向上增长的平滑曲线。并且从柱状图可以看出，在1000次循环执行结束，运行了System.gc（）后，虽然整个新生代Eden和Survivor区都基本被清空了，但是代表老年代的柱状图仍然保持峰值状态，说明被填充进堆中的数据在System.gc（）方法执行之后仍然存活。</p>
<ul>
<li>Eden区</li>
</ul>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021236149.png" style="zoom: 67%;" /></figure>

<ul>
<li>整个堆区：</li>
</ul>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021237074.png" style="zoom: 67%;" /></figure>

<ol>
<li>虚拟机启动参数只限制了Java堆为100MB，没有指定-Xmn参数，能否从监控图中估计出新生代有多大？<ul>
<li>问题1答案：图4-6显示Eden空间为637720KB，因为没有设置-XX：SurvivorRadio参数， 所以Eden与Survivor空间比例为默认值8:1，整个新生代空间大约为637720KB×125%&#x3D;797150KB。</li>
</ul>
</li>
<li>为何执行了System.gc（）之后，图中代表老年代的柱状图仍然显示峰值状态，代码需要如何调整才能让System.gc（）回收掉填充到堆中的对象？<ul>
<li>问题2答案：执行完System.gc（）之后，空间未能回收是因为List＜OOMObject＞list对象 仍然存活，fillHeap（）方法仍然没有退出，因此list对象在System.gc（）执行时仍然处于作 用域之内[2]。如果把System.gc（）移动到fillHeap（）方法外调用就可以回收掉全部内存。</li>
</ul>
</li>
</ol>
<h4 id="3-3-1-2-线程监控"><a href="#3-3-1-2-线程监控" class="headerlink" title="3.3.1.2 线程监控"></a>3.3.1.2 线程监控</h4><p>​		如果上面的“内存”页签相当于可视化的jstat命令的话，“线程”页签的功能相当于可视化的jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。前面讲解jstack命令的时候提到过线程长时间停顿的主要原因主要有：等待外部资源（数据库连接、网络资源、设备资源等）、死循环、锁等待（活锁和死锁）。通过代码分别演示一下这几种情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*线程死循环演示</span><br><span class="line">*/</span><br><span class="line">public static void createBusyThread（）&#123;</span><br><span class="line">Thread thread=new Thread（new Runnable（）&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run（）&#123;</span><br><span class="line">while（true）//第41行</span><br><span class="line">；</span><br><span class="line">&#125;</span><br><span class="line">&#125;，&quot;testBusyThread&quot;）；</span><br><span class="line">thread.start（）；</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*线程锁等待演示</span><br><span class="line">*/</span><br><span class="line">public static void createLockThread（final Object lock）&#123;</span><br><span class="line">Thread thread=new Thread（new Runnable（）&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run（）&#123;</span><br><span class="line">synchronized（lock）&#123;</span><br><span class="line">try&#123;</span><br><span class="line">lock.wait（）；</span><br><span class="line">&#125;catch（InterruptedException e）&#123;</span><br><span class="line">e.printStackTrace（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;，&quot;testLockThread&quot;）；</span><br><span class="line">thread.start（）；</span><br><span class="line">&#125;</span><br><span class="line">public static void main（String[]args）throws Exception&#123;</span><br><span class="line">BufferedReader br=new BufferedReader（new InputStreamReader（System.in））；</span><br><span class="line">br.readLine（）；</span><br><span class="line">createBusyThread（）；</span><br><span class="line">br.readLine（）；</span><br><span class="line">Object obj=new Object（）；</span><br><span class="line">createLockThread（obj）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行后，首先在“线程”页签中选择main线程，如图所示。堆栈追踪显示BufferedReader在readBytes方法中等待System.in的键盘输入，这时线程为Runnable状态，Runnable状态的线程会被分配运行时间，但readBytes方法检查到流没有更新时会立刻归还执行令牌，这种等待只消耗很小的CPU资源。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021631509.png" style="zoom: 67%;" /></figure>

<p>​		接着监控testBusyThread线程，如图所示，testBusyThread线程一直在执行空循环，从堆栈追踪中看到一直在MonitoringTest.java代码的15行停留，15行为：while（true）。这时候线程为Runnable状态，而且没有归还线程执行令牌的动作，会在空循环上用尽全部执行时间直到线程切换，这种等待会消耗较多的CPU资源。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021632722.png" style="zoom: 67%;" /></figure>

<p>​		图显示testLockThread线程在等待着lock对象的notify或notifyAll方法的出现，线程这时候处于WAITING状态，在被唤醒前不会被分配执行时间。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021634495.png" style="zoom: 67%;" /></figure>

<p>​		testLockThread线程正在处于正常的活锁等待，只要lock对象的notify（）或notifyAll（）方法被调用，这个线程便能激活以继续执行。下列代码演示了一个无法再被激活的死锁等待。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*线程死锁等待演示</span><br><span class="line">*/</span><br><span class="line">static class SynAddRunalbe implements Runnable&#123;</span><br><span class="line">int a,b；</span><br><span class="line">public SynAddRunalbe（int a,int b）&#123;</span><br><span class="line">this.a=a；</span><br><span class="line">this.b=b；</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run（）&#123;</span><br><span class="line">synchronized（Integer.valueOf（a））&#123;</span><br><span class="line">synchronized（Integer.valueOf（b））&#123;</span><br><span class="line">System.out.println（a+b）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main（String[]args）&#123;</span><br><span class="line">for（int i=0；i＜100；i++）&#123;</span><br><span class="line">new Thread（new SynAddRunalbe（1，2））.start（）；</span><br><span class="line">new Thread（new SynAddRunalbe（2，1））.start（）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这段代码开了200个线程去分别计算1+2以及2+1的值，其实for循环是可省略的，两个线程也可能会导致死锁，不过那样概率太小，需要尝试运行很多次才能看到效果。一般的话，带for循环的版本最多运行2～3次就会遇到线程死锁，程序无法结束。造成死锁的原因是Integer.valueOf（）方法基于减少对象创建次数和节省内存的考虑，[-128，127]之间的数字会被缓存[3]，当valueOf（）方法传入参数在这个范围之内，将直接返回缓存中的对象。也就是说，代码中调用了200次Integer.valueOf（）方法一共就只返回了两个不同的对象。假如在某个线程的两个synchronized块之间发生了一次线程切换，那就会出现线程A等着被线程B持有的Integer.valueOf（1），线程B又等着被线程A持有的Integer.valueOf（2），结果出现大家都跑不下去的情景。</p>
<p>​		出现线程死锁之后，点击JConsole线程面板的“检测到死锁”按钮，将出现一个新的“死锁”页签，如图所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021639698.png" style="zoom: 67%;" /></figure>

<p>​		</p>
<p>​		图中很清晰地显示了线程Thread-35在等待一个被线程Thread-36持有Integer对象，而点击线程Thread-36则显示它也在等待一个Integer对象，被线程Thread-35持有，这样两个线程就互相卡住，都不存在等到锁释放的希望了。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021641000.png" style="zoom: 67%;" /></figure>

<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021646168.png" style="zoom: 67%;" /></figure>

<h3 id="3-3-2-VisualVM：多合一故障处理工具"><a href="#3-3-2-VisualVM：多合一故障处理工具" class="headerlink" title="3.3.2 VisualVM：多合一故障处理工具"></a>3.3.2 VisualVM：多合一故障处理工具</h3><p>​		VisualVM（All-in-OneJavaTroubleshootingTool）是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。官方在VisualVM的软件说明中写上了“All-in-One”的描述字样，预示着它除了运行监视、故障处理外，还提供了很多其他方面的功能。如性能分析（Profiling），VisualVM的性能分析功能甚至比起JProfiler、YourKit等专业且收费的Profiling工具都不会逊色多少，而且VisualVM的还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。</p>
<p>​		VisualVM基于NetBeans平台开发，因此它一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM可以做到：</p>
<ul>
<li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</li>
<li>监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</li>
<li>dump以及分析堆转储快照（jmap、jhat）。</li>
<li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li>
<li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</li>
</ul>
<p>​		其他plugins的无限的可能性……</p>
<p>​		VisualVM在JDK1.6update7中才首次出现，但并不意味着它只能监控运行于JDK1.6上的程序，它具备很强的向下兼容能力，甚至能向下兼容至近10年前发布的JDK1.4.2平台，这对无数已经处于实施、维护的项目很有意义。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021700415.png" style="zoom:67%;" /></figure>

<p>​		VisualVM中“概述”、“监视”、“线程”、“MBeans”的功能与前面介绍的JConsole差别不大，读者根据上文内容类比使用即可，下面挑选几个特色功能、插件进行介绍。</p>
<ul>
<li>​		生成、浏览堆转储快照</li>
</ul>
<p>​		在VisualVM中生成dump文件有两种方式，可以执行下列任一操作：</p>
<p>​		在“应用程序”窗口中右键单击应用程序节点，然后选择“堆Dump”。</p>
<p>​		在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视”标签中单击“堆Dump”。</p>
<p>​		生成了dump文件之后，应用程序页签将在该堆的应用程序下增加一个以[heapdump]开头的子节点，并且在主页签中打开了该转储快照，如图所示。如果需要把dump文件保存或发送出去，要在heapdump节点上右键选择“另存为”菜单，否则当VisualVM关闭时，生成的dump文件会被当做临时文件删除掉。要打开一个已经存在的dump文件，通过文件菜单中的“装入”功能，选择硬盘上的dump文件即可。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021707240.png" style="zoom:67%;" /></figure>

<p>​		从堆页签中的“摘要”面板可以看到应用程序dump时的运行时参数、System.getProperties（）的内容、线程堆栈等信息，“类”面板则是以类为统计口径统计类的实例数量、容量信息，“实例”面板不能直接使用，因为不能确定用户想查看哪个类的实例，所以需要通过“类”-面板进入，在“类”中选择一个关心的类后双击鼠标，即可在“实例”里面看见此类中500个实例的具体属性信息。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021713771.png" style="zoom:67%;" /></figure>

<ul>
<li>​		分析程序性能</li>
</ul>
<p>​		在Profiler页签中，VisualVM提供了程序运行期间方法级的CPU执行时间分析以及内存分析，做Profiling分析肯定会对程序运行性能有比较大的影响，所以一般不在生产环境中使用这项功能。要开始分析，先选择“CPU”和“内存”按钮中的一个，然后切换到应用程序中对程序进行操作，VisualVM会记录到这段时间中应用程序执行过的方法。如果是CPU分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析，则会统计每个方法关联的对象数以及这些对象所占的空间。分析结束后，点击“停止”按钮结束监控过程，如图所示。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205021730964.png" style="zoom:67%;" /></figure>

<ul>
<li>​		BTrace动态日志跟踪</li>
</ul>
<p>​		BTrace是一个很“有趣”的VisualVM插件，本身也是可以独立运行的程序。它的作用是在不停止目标程序运行的前提下，通过HotSpot虚拟机的HotSwap技术动态加入原本并不存在的调试代码。这项功能对实际生产中的程序很有意义：经常遇到程序出现问题，但排查错误的一些必要信息，譬如方法参数、返回值等，在开发时并没有打印到日志之中，以至于不得不停掉服务，通过调试增量来加入日志代码以解决问题。当遇到生产环境服务无法随便停止时，缺一两句日志导致排错进行不下去是一件非常郁闷的事情。在VisualVM中安装了BTrace插件后，在应用程序面板中右键点击要调试的程序，会出现“TraceApplication……”菜单，点击将进入BTrace面板。这个面板里面看起来就像一个简单的Java程序开发环境，里面还有一小段Java代码。</p>
<p>​		BTrace的用法还有许多，打印调用堆栈、参数、返回值只是最基本的应用，在它的网站 上有使用BTrace进行性能监视、定位连接泄漏和内存泄漏、解决多线程竞争问题等例子，有 兴趣的读者可以去相关网站了解一下。</p>
<h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>​		本章介绍了随JDK发布的6个命令行工具及两个可视化的故障处理工具，灵活使用这些工具可以给问题处理带来很大的便利。除了JDK自带的工具之外，常用的故障处理工具还有很多，如果读者使用的是非Sun系列的JDK、非HotSpot的虚拟机，就需要使用对应的工具进行分析……</p>
<hr>
<h1 id="四-调优案例分析与实战"><a href="#四-调优案例分析与实战" class="headerlink" title="四 调优案例分析与实战"></a>四 调优案例分析与实战</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>​		上文介绍了处理Java虚拟机内存问题的知识与工具，在处理实际项目的问题时，除了知识与工具外，经验同样是一个很重要的因素。因此本章将与读者分享几个比较有代表性的实际案例。考虑到虚拟机故障处理和调优主要面向各类服务端应用，而大部分Java程序员较少有机会直接接触生产环境的服务器，因此本章还准备了一个所有开发人员都能够进行“亲身实战”的练习，希望通过实践使读者获得故障处理和调优的经验。</p>
<h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><h3 id="4-2-1-高性能硬件上的程序部署策略"><a href="#4-2-1-高性能硬件上的程序部署策略" class="headerlink" title="4.2.1 高性能硬件上的程序部署策略"></a>4.2.1 高性能硬件上的程序部署策略</h3><p>​		例如，一个15万PV&#x2F;天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个CPU、16GB物理内存，操作系统为64位CentOS5.4，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的网站使用。管理员为了尽量利用硬件资源选用了64位的JDK1.5，并通过-Xmx和-Xms参数将Java堆固定在12GB。使用一段时间后发现使用效果并不理想，网站经常不定期出现长时间失去响应的情况。</p>
<p>监控服务器运行状况后发现网站失去响应是由<strong>GC停顿</strong>导致的，<strong>虚拟机运行在Server模式，默认使用吞吐量优先收集器</strong>，回收12GB的堆，一次FullGC的停顿时间高达14秒。并且由于程序设计的关系，访问文档时要把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有在MinorGC中清理掉。这种情况下即使有12GB的堆，内存也很快被消耗殆尽，由此导致每隔十几分钟出现十几秒的停顿，令网站开发人员和管理员感到很沮丧。</p>
<p>这里先不延伸讨论程序代码问题，程序部署上的主要问题显然是过大的堆内存进行回收时带来的长时间的停顿。硬件升级前使用32位系统1.5GB的堆，用户只感觉到使用网站比较缓慢，但不会发生十分明显的停顿，因此才考虑升级硬件以提升程序效能，如果重新缩小给Java堆分配的内存，那么硬件上的投资就显得很浪费。在高性能硬件上部署程序，目前主要有两种方式：</p>
<ul>
<li><p><strong>通过64位JDK来使用大内存。</strong></p>
</li>
<li><p>l<strong>使用若干个32位虚拟机建立逻辑集群来利用硬件资源。</strong></p>
</li>
</ul>
<p>​		此案例中的管理员采用了第一种部署方式。对于用户交互性强、对停顿时间敏感的系统，<strong>可以给Java虚拟机分配超大堆的前提是有把握把应用程序的FullGC频率控制得足够低</strong>，至少要低到不会影响用户使用，譬如十几个小时乃至一天才出现一次FullGC，这样可以通过在深夜执行定时任务的方式触发FullGC甚至自动重启应用服务器来保持内存可用空间在一个稳定的水平。</p>
<p>​		<strong>控制FullGC频率的关键是看应用中绝大多数对象能否符合“朝生夕灭”的原则</strong>，即大多数对象的生存时间不应太长，尤其是<strong>不能有成批量的、长生存时间的大对象产生</strong>，<strong>这样才能保障老年代空间的稳定</strong>。</p>
<p>​		在大多数网站形式的应用里，主要对象的生存周期都应该是请求级或者页面级的，会话级和全局级的长生命对象相对很少。只要代码写得合理，应当都能实现在超大堆中正常使用而没有FullGC，这样的话，使用超大堆内存时，网站响应速度才会比较有保证。除此之外，如果读者计划<strong>使用64位JDK来管理大内存，还需要考虑下面可能面临的问题：</strong></p>
<ul>
<li><p>​		<strong>内存回收导致的长时间停顿</strong>。</p>
</li>
<li><p>​		现阶段，<strong>64位JDK的性能测试结果普遍低于32位JDK</strong>。</p>
</li>
<li><p>​		需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生十几GB乃至更大的Dump文件），哪怕产生了快照也几乎无法进行分析。</p>
</li>
<li><p>​		<strong>相同程序在64位JDK消耗的内存一般比32位JDK大</strong>，<strong>这是由于指针膨胀</strong>，<strong>以及数据类型对齐补白等因素导致的</strong>。</p>
</li>
</ul>
<p>​		上面的问题听起来有点吓人，<strong>所以现阶段不少管理员还是选择第二种方式：使用若干个32位虚拟机建立逻辑集群来利用硬件资源。具体做法是在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</strong>读者不需要太过在意均衡器转发所消耗的性能，即使使用64位JDK，许多应用也不止有一台服务器，因此在许多应用中前端的均衡器总是要存在的。</p>
<p>​		考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性需求，也不需要保证每个虚拟机进程有绝对准确的均衡负载，因此使用无Session复制的<strong>亲合式集群</strong>是一个相当不错的选择。</p>
<p>​		我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据SessionID分配）将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可，这样程序开发阶段就基本不用为集群环境做什么特别的考虑了。当然，很少有没有缺点的方案，如果读者计划使用逻辑集群的方式来部署程序，可能会遇到下面一些问题：</p>
<ul>
<li>尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致IO异常。</li>
<li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI，但这个有一定复杂性并且可能带来额外的性能开销。</li>
<li>各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些Linux或UNIX系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB（232）内存的限制。</li>
<li>大量使用本地缓存（如大量使用HashMap作为K&#x2F;V缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。</li>
</ul>
<p>​		介绍完这两种部署方式，再重新回到这个案例之中，<strong>最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了10GB内存。另外建立一个Apache服务作为前端均衡代理访问门户。考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问，CPU资源敏感度较低，因此改为CMS</strong>收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较大提升。</p>
<h3 id="4-2-3-堆外内存导致的溢出错误"><a href="#4-2-3-堆外内存导致的溢出错误" class="headerlink" title="4.2.3 堆外内存导致的溢出错误"></a>4.2.3 堆外内存导致的溢出错误</h3><p>​		例如，一个学校的小型项目：基于B&#x2F;S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据，系统使用了逆向AJAX技术（也称为Comet或者ServerSidePush），选用CometD1.1.1作为服务端推送框架，服务器是Jetty7.1.4，硬件为一台普通PC机，Corei5CPU，4GB内存，运行32位Windows操作系统。</p>
<p>​		测试期间发现服务端不定时抛出内存溢出异常，服务器不一定每次都会出现异常，但假如正式考试时崩溃一次，那估计整场电子考试都会乱套，网站管理员尝试过把堆开到最大，而32位系统最多到1.6GB就基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁了。加入-XX：+HeapDumpOnOutOfMemoryError，居然也没有任何反应，抛出内存溢出异常时什么文件都没有产生。无奈之下只好挂着jstat并一直紧盯屏幕，发现GC并不频繁，Eden区、Survivor区、老年代以及永久代内存全部都表示“情绪稳定，压力不大”，但就是照样不停地抛出内存溢出异常，管理员压力很大。最后，在内存溢出后从系统日志中找到异常堆栈，如代码清单所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[org.eclipse.jetty.util.log]handle failed java.lang.OutOfMemoryError：<span class="literal">null</span></span><br><span class="line">at sun.misc.Unsafe.allocateMemory（Native Method）</span><br><span class="line">at java.nio.DirectByteBuffer.＜init＞（DirectByteBuffer.java：<span class="number">99</span>）</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect（ByteBuffer.java：<span class="number">288</span>）</span><br><span class="line">at org.eclipse.jetty.io.nio.DirectNIOBuffer.＜init＞</span><br></pre></td></tr></table></figure>

<p>​		如果认真阅读过本书的第2章，看到异常堆栈就应该清楚这个抛出内存溢出异常是怎么回事了。大家知道操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位Windows平台的限制是2GB，其中划了1.6GB给Java堆，而DirectMemory内存并不算入1.6GB的堆之内，因此它最大也只能在剩余的0.4GB空间中分出一部分。在此应用中导致溢出的关键是：垃圾收集进行时，虚拟机虽然会对DirectMemory进行回收，但是<strong>DirectMemory却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后FullGC，然后“顺便地”帮它清理掉内存的废弃对象。</strong>否则它只能一直等到抛出内存溢出异常时，先catch掉，再在catch块里面“大喊”一声：“System.gc（）！”。要是虚拟机还是不听（譬如打开了-XX：+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。而本案例中使用的CometD1.1.1框架，正好有<strong>大量的NIO操作</strong>需要使用到DirectMemory内存。</p>
<p>​		从实践经验的角度出发，除了Java堆和永久代之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和受到操作系统进程最大内存的限制。</p>
<ul>
<li><p><strong>DirectMemory</strong>：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError：Directbuffermemory。</p>
</li>
<li><p><strong>线程堆栈</strong>：可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或者OutOfMemoryError：unabletocreatenewnativethread（横向无法分配，即无法建立新的线程）。</p>
</li>
<li><p><strong>Socket缓存区</strong>：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException：Toomanyopenfiles异常。</p>
</li>
<li><p><strong>JNI代码</strong>：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</p>
</li>
<li><p><strong>虚拟机和GC</strong>：虚拟机、GC的代码执行也要消耗一定的内存。</p>
</li>
</ul>
<h3 id="4-2-4-外部命令导致系统缓慢"><a href="#4-2-4-外部命令导致系统缓慢" class="headerlink" title="4.2.4 外部命令导致系统缓慢"></a>4.2.4 外部命令导致系统缓慢</h3><p>​		这是一个来自网络的案例：一个数字校园应用系统，运行在一台4个CPU的Solaris10操作系统上，中间件为GlassFish服务器。系统在做大并发压力测试的时候，发现请求响应时间比较慢，通过操作系统的mpstat工具发现CPU使用率很高，并且系统占用绝大多数的CPU资源的程序并不是应用系统本身。这是个不正常的现象，通常情况下用户应用的CPU占用率应该占主要地位，才能说明系统是正常工作的。</p>
<p>​		通过Solaris10的Dtrace脚本可以查看当前情况下哪些系统调用花费了最多的CPU资源，Dtrace运行后发现最消耗CPU资源的竟然是“fork”系统调用。众所周知，“fork”系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码最多只有线程的概念，不应当有进程的产生。</p>
<p>​		这是个非常异常的现象。通过本系统的开发人员，最终找到了答案：每个用户请求的处理都需要执行一个外部shell脚本来获得系统的一些信息。<strong>执行这个shell脚本是通过Java的Runtime.getRuntime（）.exec（）方法来调用的。这种调用方式可以达到目的，但是它在Java虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。</strong>Java虚拟机执行这个命令的过程是：首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU，内存负担也很重。</p>
<p>​		用户根据建议去掉这个Shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快恢复了正常。</p>
<h3 id="4-2-5-不恰当数据结构导致内存占用过大"><a href="#4-2-5-不恰当数据结构导致内存占用过大" class="headerlink" title="4.2.5 不恰当数据结构导致内存占用过大"></a>4.2.5 不恰当数据结构导致内存占用过大</h3><p>​		例如，有一个后台RPC服务器，使用64位虚拟机，内存配置为-Xms4g-Xmx8g-Xmn1g，使用ParNew+CMS的收集器组合。平时对外服务的MinorGC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap＜Long,Long＞Entry，在这段时间里面MinorGC就会造成超过500毫秒的停顿，对于这个停顿时间就接受不了了，具体情况如下面GC日志所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=95（full 4）：</span><br><span class="line">par new generation total 903168K,used 803142K[0x00002aaaae770000，0x00002aaaebb70000，0x00002aaaebb70000）</span><br><span class="line">eden space 802816K，100%used[0x00002aaaae770000，0x00002aaadf770000，0x00002aaadf770000）</span><br><span class="line">from space 100352K，0%used[0x00002aaae5970000，0x00002aaae59c1910，0x00002aaaebb70000）</span><br><span class="line">to space 100352K，0%used[0x00002aaadf770000，0x00002aaadf770000，0x00002aaae5970000）</span><br><span class="line">concurrent mark-sweep generation total 5845540K,used 3898978K[0x00002aaaebb70000，0x00002aac507f9000，0x00002aacae770000）</span><br><span class="line">concurrent-mark-sweep perm gen total 65536K,used 40333K[0x00002aacae770000，0x00002aacb2770000，0x00002aacb2770000）</span><br><span class="line">2 0 1 1-1 0-2 8 T 1 1：4 0：4 5.1 6 2+0 8 0 0：2 2 6.5 0 4：[G C 2 2 6.5 0 4：[P a r N e w：803142K-＞100352K（903168K），0.5995670 secs]4702120K-＞</span><br><span class="line">4056332K（6748708K），0.5997560</span><br><span class="line">secs][Times：user=1.46 sys=0.04，real=0.60 secs]</span><br><span class="line">Heap after GC invocations=96（full 4）：</span><br><span class="line">par new generation total 903168K,used 100352K[0x00002aaaae770000，0x00002aaaebb70000，0x00002aaaebb70000）</span><br><span class="line">eden space 802816K，0%used[0x00002aaaae770000，0x00002aaaae770000，0x00002aaadf770000）</span><br><span class="line">from space 100352K，100%used[0x00002aaadf770000，0x00002aaae5970000，</span><br><span class="line">0x00002aaae5970000）</span><br><span class="line">to space 100352K，0x00002aaaebb70000）0%used[0x00002aaae5970000，0x00002aaae5970000，</span><br><span class="line">concurrent mark-sweep generation total 5845540K,used 3955980K[0x00002aaaebb70000，0x00002aac507f9000，0x00002aacae770000）</span><br><span class="line">concurrent-mark-sweep perm gen total 65536K,used 40333K[0x00002aacae770000，0x00002aacb2770000，0x00002aacb2770000）</span><br><span class="line">&#125;</span><br><span class="line">Total time for which application threads were stopped：0.6070570 seconds</span><br></pre></td></tr></table></figure>

<p>​		观察这个案例，发现平时的MinorGC时间很短，原因是新生代的绝大部分对象都是可清除的，在MinorGC之后Eden和Survivor基本上处于完全空闲的状态。而在分析数据文件期间，800MB的Eden空间很快被填满从而引发GC，但MinorGC之后，新生代中绝大部分对象依然是存活的。我们知道ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确就成为一个沉重的负担，因此导致GC暂停时间明显变长。</p>
<p>​		如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑将Survivor空间去掉（加入参数-XX：SurvivorRatio&#x3D;65536、-XX：MaxTenuringThreshold&#x3D;0或者-XX：+AlwaysTenure），让新生代中存活的对象在第一次MinorGC后立即进入老年代，等到MajorGC的时候再清理它们。这种措施可以治标，但也有很大副作用，治本的方案需要修改程序，因为这里的问题产生的根本原因是用HashMap＜Long,Long＞结构来存储数据文件空间效率太低。</p>
<p>​		下面具体分析一下空间效率。在HashMap＜Long,Long＞结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16B（2×8B）。这两个长整型数据包装成java.lang.Long对象之后，就分别具有8B的MarkWord、8B的Klass指针，在加8B存储数据的long值。在这两个Long对象组成Map.Entry之后，又多了16B的对象头，然后一个8B的next字段和4B的int型的hash字段，为了对齐，还必须添加4B的空白填充，最后还有HashMap中对这个Entry的8B的引用，这样增加两个长整型数字，实际耗费的内存为（Long（24B）×2）+Entry（32B）+HashMapRef（8B）&#x3D;88B，空间效率为16B&#x2F;88B&#x3D;18%，实在太低了。</p>
<h2 id="4-3-本章小结"><a href="#4-3-本章小结" class="headerlink" title="4.3 本章小结"></a>4.3 本章小结</h2><p>​		Java虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对程序的性能和稳定性有非常大的影响，笔者从理论知识、异常现象、代码、工具、案例、实战等几个方面对其进行了讲解，希望读者有所收获。本书关于虚拟机内存管理部分到此为止就结束了，后面将开始介绍Class文件与虚拟机执行子系统方面的知识。</p>

	

	
		<span class="different-posts"><a href="/2022/05/03/JVM-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />I’m Fan Y，they know me as a Chinese🧑 and boring guy，but i have fun-filled stories.Have you look arround？I like 💤🛫📕🌳🌳🌳</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2022 Fresh Y | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
