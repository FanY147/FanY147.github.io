<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>JAVA并发编程 | MyBlog</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="MyBlog" type="application/atom+xml">
    
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

	<header class="header">
		<nav class="header__nav">
			
		</nav>
		<h1 class="header__title"><a href="/">MyBlog</a></h1>
		<h2 class="header__subtitle">READ&LEARNING&LIFE&PHOTOGRAPHY</h2>
	</header>

	<main>
		<article>
	
		<h1>JAVA并发编程</h1>
	
	<div class="article__infos">
		<span class="article__date">2022-05-07</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/JAVA/" rel="tag">JAVA</a> <a class="article__tag-none-link" href="/tags/Learing/" rel="tag">Learing</a> <a class="article__tag-none-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a>
			</span>
		
	</div>

	

	
		<h1 id="一、-初识并发编程"><a href="#一、-初识并发编程" class="headerlink" title="一、 初识并发编程"></a>一、 初识并发编程</h1><blockquote>
<p>并发编程的目的是为了让程序更快，但并不是越多的线程参与就能使程序最大限度地并发执行。</p>
</blockquote>
<span id="more"></span>

<h2 id="1-1-何为上下文切换"><a href="#1-1-何为上下文切换" class="headerlink" title="1.1 何为上下文切换"></a>1.1 何为上下文切换</h2><p><strong>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</strong></p>
<p>这就像我们同时读两本书，当我们在读一本英文的技术书时，发现某个单词不认识，于是便打开中英文字典，但是在放下英文技术书之前，大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读书效率的，同样上下文切换也会影响多线程的执行速度。</p>
<h4 id="某些情况下并发比串行执行慢的原因"><a href="#某些情况下并发比串行执行慢的原因" class="headerlink" title="某些情况下并发比串行执行慢的原因"></a>某些情况下并发比串行执行慢的原因</h4><p>因为线程有创建和上下文切换的开销。</p>
<h4 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h4><ul>
<li>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。 </li>
<li>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一 些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li>
<li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</li>
<li>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这 样会造成大量线程都处于等待状态。 </li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ul>
<h4 id="避免死锁的几个常见方法。"><a href="#避免死锁的几个常见方法。" class="headerlink" title="避免死锁的几个常见方法。"></a>避免死锁的几个常见方法。</h4><ul>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li>
</ul>
<h1 id="二、-JAVA并发的底层实现原理"><a href="#二、-JAVA并发的底层实现原理" class="headerlink" title="二、 JAVA并发的底层实现原理"></a>二、 JAVA并发的底层实现原理</h1><h4 id="2-1-volatile的应用"><a href="#2-1-volatile的应用" class="headerlink" title="2.1 volatile的应用"></a>2.1 volatile的应用</h4><p>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。<strong>可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</strong>如果volatile变量修饰符使用恰当的话，<strong>它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</strong></p>
<p>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，<strong>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</strong></p>
<p>下面来具体讲解volatile的两条实现原则。</p>
<ol>
<li><strong>Lock前缀指令会引起处理器缓存回写到内存</strong>。Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</li>
<li><strong>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</strong>。IA-32处理器和Intel64处理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</li>
</ol>
<h3 id="2-2-synchronized的实现原理和应用"><a href="#2-2-synchronized的实现原理和应用" class="headerlink" title="2.2 synchronized的实现原理和应用"></a>2.2 synchronized的实现原理和应用</h3><p>先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p>
<p><strong>对于普通同步方法，锁是当前实例对象。</strong></p>
<p><strong>对于静态同步方法，锁是当前类的Class对象。</strong></p>
<p><strong>对于同步方法块，锁是Synchonized括号里配置的对象。</strong></p>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？</p>
<p>从JVM规范中可以看到Synchonized在JVM里的实现原理，<strong>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，</strong>细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</p>
<p><strong>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。</strong>线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
<h4 id="2-2-1-锁的升级和对比"><a href="#2-2-1-锁的升级和对比" class="headerlink" title="2.2.1 锁的升级和对比"></a>2.2.1 锁的升级和对比</h4><p>JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，</strong>这几个状态会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，</strong>下文会详细分析。</p>
<h4 id="2-2-1-1-偏向锁"><a href="#2-2-1-1-偏向锁" class="headerlink" title="2.2.1.1 偏向锁"></a>2.2.1.1 偏向锁</h4><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，<strong>为了让线程获得锁的代价更低而引入了偏向锁。</strong>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的MarkWord里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下MarkWord中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>（1）偏向锁的撤销</p>
<p><strong>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</strong>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的MarkWord要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。图2-1中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205101613597.png" style="zoom: 80%;" /></figure>

<p>（2）关闭偏向锁</p>
<p>偏向锁在Java6和Java7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay&#x3D;0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking&#x3D;false，那么程序默认会进入轻量级锁状态。</p>
<h4 id="2-2-1-2-轻量级锁"><a href="#2-2-1-2-轻量级锁" class="headerlink" title="2.2.1.2 轻量级锁"></a>2.2.1.2 轻量级锁</h4><p>（1）轻量级锁</p>
<p>加锁线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中，官方称为DisplacedMarkWord。<strong>然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</strong></p>
<p>（2）轻量级锁解锁</p>
<p><strong>轻量级解锁时，会使用原子的CAS操作将DisplacedMarkWord替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</strong>。图2-2是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205101620749.png" style="zoom: 80%;" /></figure>

<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h4 id="2-2-1-3-锁的优缺点对比"><a href="#2-2-1-3-锁的优缺点对比" class="headerlink" title="2.2.1.3 锁的优缺点对比"></a>2.2.1.3 锁的优缺点对比</h4><figure class="figure"><img src="https://raw.githubusercontent.com/FanY147/imgsRepo/master/img/202205101623786.png" style="zoom:80%;" /></figure>

<h2 id="2-3-原子操作的实现原理"><a href="#2-3-原子操作的实现原理" class="headerlink" title="2.3 原子操作的实现原理"></a>2.3 原子操作的实现原理</h2>
	

	
		<span class="different-posts"><a href="/2022/05/07/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<h5>Hi there</h5>
	<p>I’m Fan Y，they know me as a Chinese🧑, I have some fun-filled stories to share with u.I like 💤🛫📕🌳🌳🌳</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2022 Fresh Y | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
