<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>JAVA知识点 | MyBlog</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="MyBlog" type="application/atom+xml">
    
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

	<header class="header">
		<nav class="header__nav">
			
		</nav>
		<h1 class="header__title"><a href="/">MyBlog</a></h1>
		<h2 class="header__subtitle">READ&LEARNING&LIFE&PHOTOGRAPHY</h2>
	</header>

	<main>
		<article>
	
		<h1>JAVA知识点</h1>
	
	<div class="article__infos">
		<span class="article__date">2022-05-07</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/JAVA/" rel="tag">JAVA</a> <a class="article__tag-none-link" href="/tags/Learning/" rel="tag">Learning</a>
			</span>
		
	</div>

	

	
		<h4 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h4><ul>
<li>方法名相同</li>
<li>参数列表相同（数量，顺序，数据类型）</li>
<li>如果被重写的方法的返回值是void，重写的方法的返回值必须也是void；如果被重写的方法的返回值是基本数据类型，重写方法的返回值也必须是相同的基本数据类型；返回的类型如果是引用类型，重写的方法的返回值必须和被重写的返回值类型相同，或者是被重写方法返回值类型的子类。</li>
<li>子类重写的方法不能缩小父类被重写方法的访问权限，子类重写方法的访问权限必须大于等于父类被重写方法的访问权限。</li>
<li>重写对privae无效。</li>
<li>如果方法签名相同，父类和子类的方法必须同时为静态或者非静态。</li>
<li>不能抛出比父类更多的异常</li>
<li>final方法不能被子类重写</li>
</ul>
<span id="more"></span>

<h4 id="父类静态方法能否被重写？"><a href="#父类静态方法能否被重写？" class="headerlink" title="父类静态方法能否被重写？"></a>父类静态方法能否被重写？</h4><p>父类的普通方法可以被继承和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020">重写</a>，不多作解释，如果子类继承父类，而且子类没有重写父类的方法，但是子类会有从父类继承过来的方法。</p>
<p><strong>静态的方法可以被继承，但是不能重写</strong>。如果父类中有一个静态的方法，子类也有一个与其方法名，参数类型，参数个数都一样的方法，并且也有static关键字修饰，那么该子类的方法会把原来继承过来的父类的方法隐藏，而不是重写。通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，具体调用哪一个方法是看是哪个对象的引用；这种父子类方法也不在存在多态的性质。《Java编程思想》中这样提到:</p>
<blockquote>
<p>“<strong>只有普通的方法调用可以是多态的</strong>”。<strong>成员变量和静态方法不具有多态性</strong>。</p>
</blockquote>
<h4 id="C-与JAVA"><a href="#C-与JAVA" class="headerlink" title="C++与JAVA"></a>C++与JAVA</h4><p>相同点：</p>
<ol>
<li>C++与JAVA都是静态类型语言，静态类型语言的关键特征是它的类型检查的主体过程是在编译器而不是运行期进行的。</li>
<li></li>
</ol>
<p>不同点：</p>
<p>1. </p>
<h4 id="抽象类和接口的异同"><a href="#抽象类和接口的异同" class="headerlink" title="抽象类和接口的异同"></a>抽象类和接口的异同</h4><p>相同点：</p>
<ol>
<li>都不能被实例化。</li>
<li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中方法后才能实例化。</li>
</ol>
<p>不同点：</p>
<ol>
<li><p>在成员变量上，抽象类可以有变量、常量、构造方法、有抽象方法也可以有非抽象方法；接口只能有常量、抽象方法。</p>
</li>
<li><p>在使用上，接口侧重于实现封装（接口隐藏内部实现），抽象类侧重于提取共性。</p>
<p>接口只有定义不能有方法实现（Java 1.8中可以定义default方法体），抽象类可以有定义与实现，方法可在抽象类中实现。</p>
</li>
<li><p>在继承上，接口可以继承多个父类，抽象类只能继承一个父类。</p>
</li>
<li><p>抽象类可以有构造器，抽象方法可以有public、protected和default这些修饰符；接口不能有构造器，接口方法默认修饰符是public，不可以使用其它修饰符。</p>
</li>
</ol>
<h4 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h4><ul>
<li>静态方法只能访问静态成员</li>
<li>非静态方法可以访问所有成员</li>
<li>访问时要遵守相关访问权限</li>
<li>首先肯定:<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">静态变量</a>是被对象共享的</li>
<li>jdk8之前：放在方法区</li>
<li>jdk8及以后：存放在堆中反射的class对象（即<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>后会在堆中生成一个对应的class对象）的尾部</li>
</ul>
<h4 id="sleep-和wait-方法的异同"><a href="#sleep-和wait-方法的异同" class="headerlink" title="sleep()和wait()方法的异同"></a>sleep()和wait()方法的异同</h4><p>sleep()和wait()方法都是可以让线程停止执行的方法，但是两者有很多的不同之处。</p>
<p>1.原理不同。sleep()是Thread类的静态方法，是线程用来控制自身流程的，它会使线程暂停一段时间，把执行机会让给其他线程，等计时时间一到，此线程会自动“苏醒”；而wait()方法时Object类的方法，用于线程之间的通信，这个方法会使拥有对象锁的线程进入等待状态，直到其他线程调用notify方法才能“唤醒”，当然也可以指定一个时间醒来。</p>
<p>2.对锁的处理机制不同。由于sleep()方法主要是让线程暂停执行一段时间，时间一到则立即恢复运行，不涉及线程之间的通信，所以调用sleep()方法不会释放锁；当调用wait()方法后，线程释放它所占有的锁，让给其他线程去争夺锁。</p>
<p>3.使用区域不同。sleep()可以放在任何地方使用，而wait()只能放在同步方法或者同步块中使用。</p>
<p>4.sleep()必须捕获异常，而wait()不用，由于，在sleep(）的时间当中有可能被对象调用interrupt(）方法，产生InterruptException。</p>
<p>5.由于sleep()不会释放锁，容易导致“死锁”的情况发生，在多线程的时候，一般情况下用wait(）方法好。</p>
<h4 id="创建线程的方式及对比"><a href="#创建线程的方式及对比" class="headerlink" title="创建线程的方式及对比"></a>创建线程的方式及对比</h4><p>1）采用实现Runnable、Callable接口的方式创建多线程。</p>
<p>优势是：</p>
<p>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</p>
<p>在自动切换暗黑模式这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<p>劣势是：</p>
<p>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p>
<p>2）使用继承Thread类的方式创建多线程</p>
<p>优势是：</p>
<p>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。</p>
<p>劣势是：</p>
<p>线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<p>3）Runnable和Callable的区别</p>
<ol>
<li>Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。</li>
<li><strong>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的</strong>。</li>
<li><strong>Call方法可以抛出异常，run方法不可以。</strong></li>
<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ol>
<h3 id="Lock接口常用方法"><a href="#Lock接口常用方法" class="headerlink" title="Lock接口常用方法"></a>Lock接口常用方法</h3><p> Lock 接口加解锁相关的主要有 5 个方法，接下来看看这 5 种方法的作用和用法，这 5 种方法分别是 lock()、tryLock()、tryLock(long time, TimeUnit unit) 和 lockInterruptibly()、unlock()。</p>
<h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><p>最基础的获取锁的方法。在线程获取锁时如果锁已被其他线程获取，则进行等待，是最初级的获取锁的方法。</p>
<p><strong>对于 Lock 接口而言，获取锁和释放锁都是显式的，不像 synchronized 那样是隐式的</strong>，所以 Lock 不会像 synchronized 一样在异常时自动释放锁，lock 的加锁和释放锁都必须以代码的形式写出来，所以使用 lock() 时必须由我们自己主动去释放锁，因此最佳实践是<strong>执行 lock() 后，首先在 try{} 中操作同步资源，如果有必要就用 catch{} 块捕获异常，然后在 finally{} 中释放锁</strong>，以保证发生异常时锁一定被释放，示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//获取到了被本锁保护的资源，处理任务</span></span><br><span class="line">    <span class="comment">//捕获异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a><strong>tryLock()</strong></h4><p><strong>lock() 方法不能被中断</strong>，这会带来很大的隐患，一旦陷入死锁，lock() 就会陷入永久等待，所以一般我们用 <strong>tryLock()</strong> 等其他更高级的方法来代替 lock()</p>
<blockquote>
<p><strong>tryLock()</strong> 用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回 true，否则返回 false，代表获取锁失败。并且可以响应中断。</p>
</blockquote>
<p>因为该方法会立即返回，即便在拿不到锁时也不会一直等待，所以通常情况下，我们用 if 语句判断 tryLock() 的返回结果，根据是否获取到锁来执行不同的业务逻辑，典型使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用tryLock() 方法便可以解决死锁问题，如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryLock</span><span class="params">(Lock lock1,Lock lock2)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lock1.tryLock())&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(lock2.tryLock())&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;获取到了两把锁，完成业务逻辑!&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果代码中我们不用 tryLock() 方法</strong>，那么便可能会产生死锁，比如有两个线程同时调用这个方法，传入的 lock1 和 lock2 恰好是相反的，那么如果第一个线程获取了 lock1 的同时，第二个线程获取了 lock2，它们接下来便会尝试获取对方持有的那把锁，但是又获取不到，于是便会陷入死锁。</p>
<p><strong>使用tryLock() 方法之后</strong>，首先会检测 lock1 是否能获取到，如果能获取到再尝试获取 lock2，但如果 lock1 获取不到也没有关系，我们会在下面进行随机时间的等待，这个等待的目标是争取让其他的线程在这段时间完成它的任务，以便释放其他线程所持有的锁，以便后续供我们使用。只有当它同时获取到 lock1 和 lock2 的时候，才会进入到里面执行业务逻辑，比如在这里我们会打印出“获取到了两把锁，完成业务逻辑”，然后方法便会返回。</p>
<h4 id="tryLock-long-time-TimeUnit-unit"><a href="#tryLock-long-time-TimeUnit-unit" class="headerlink" title="tryLock(long time, TimeUnit unit)"></a>tryLock(long time, TimeUnit unit)</h4><blockquote>
<p>tryLock() 的重载方法是 tryLock(long time, TimeUnit unit)，参数中有一个超时时间，在拿不到锁时会等待一定的时间，如果在时间期限结束后，还获取不到锁，就会返回 false；如果一开始就获取锁或者等待期间内获取到锁，则返回 true。</p>
</blockquote>
<p>这个方法解决了 lock() 方法容易发生死锁的问题，使用 tryLock(long time, TimeUnit unit) 时，在等待了一段指定的超时时间后，线程会主动放弃这把锁的获取，避免永久等待；在等待的期间，也可以随时中断线程，这就避免了死锁的发生。</p>
<h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h4><blockquote>
<p><strong>lockInterruptibly()作用是获取锁</strong>，如果这个锁当前是可以获得的，那么这个方法会立刻返回，但是如果这个锁当前是不能获得的（被其他线程持有），那么当前线程便会开始等待，除非它等到了这把锁或者是在等待的过程中被中断了，否则这个线程便会一直在这里执行这行代码。也就是，<strong>除非当前线程在获取锁期间被中断，否则便会一直尝试获取直到获取到为止</strong>。</p>
</blockquote>
<p>lockInterruptibly() 是可以响应中断的。相比于不能响应中断的 synchronized 锁，lockInterruptibly() 可以让程序更灵活，可以在获取锁的同时，保持对中断的响应。可以把这个方法理解为超时时间是无穷长的 tryLock(long time, TimeUnit unit)，因为 tryLock(long time, TimeUnit unit) 和 lockInterruptibly() 都能响应中断，只不过 lockInterruptibly() 永远不会超时。</p>
<p><strong>lockInterruptibly()是会抛出 InterruptedException 的，所以使用的时候，如果不在方法签名声明抛出该异常，那么就要写两个 try 块</strong>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">(Lock lock)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;操作资源&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h4><p>unlock() 方法，是用于解锁的，方法比较简单，<strong>对于 ReentrantLock 而言</strong>，<strong>执行 unlock() 的时候，内部会把锁的“被持有计数器”减 1，直到减到 0 就代表当前这把锁已经完全释放了</strong>；<strong>如果减 1 后计数器不为 0，说明这把锁之前被“重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数</strong>。</p>

	

	
		<span class="different-posts"><a href="/2022/05/07/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<h5>Hi there</h5>
	<p>I’m Fan Y，they know me as a Chinese🧑, I have some fun-filled stories to share with u.I like 💤🛫📕🌳🌳🌳</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2022 Fresh Y | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
